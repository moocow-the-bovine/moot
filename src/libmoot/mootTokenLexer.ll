/*-*- Mode: Flex++; c-basic-offset: 2; -*-*/

/*
   libmoot : moocow's part-of-speech tagging library
   Copyright (C) 2003-2013 by Bryan Jurish <moocow@cpan.org>

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 3 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*/

/*----------------------------------------------------------------------
 * Name: mootTokenLexer.ll
 * Author: Bryan Jurish
 * Description:
 *   + lexer for moocow's tagger
 *   + assumes pre-tokenized input
 *     - one token per line
 *     - n>=0 (possible) tags per token
 *     - blank lines mark end-of-sentence
 *     - supports line-comments introduced by '%%'
 *     - supports word- and sentence-break hints "%%$WB$", "%%$SB$"
 *     - raw text (no markup!)
 *     - token-line format (TAB-separated)
 *        TOKEN_TEXT   LOCATION?   BESTTAG?   ANALYSIS_1 ... ANALYSIS_N
 *     - LOCATION format:
 *        OFFSET " " LENGTH
 *     - BESTTAG, analysis format(s):
 *        ...(COST?)... "[" TAG ["]"|" "] ...(COST?)...
 *     - COST format(s):
 *       "<" COST_FLOAT ">"
 *
 *   + process with Coetmeur's flex++ to produce 'mootTokenLexer.cc'
 *----------------------------------------------------------------------*/

/* --- Lexer name --- */
%name mootTokenLexer

%header{
/*============================================================================
 * Doxygen docs
 *============================================================================*/
/**
\file mootTokenLexer.h
\brief \c flex++ lexer for moot::TokenReaderNative guts: autogenerated headers

\file mootTokenLexer.ll
\brief \c flex++ lexer for moot::TokenReaderNative guts: sources

\class mootTokenLexer
\brief \c flex++ lexer for moot PoS tagger native text input (guts for moot::TokenReaderNative)
\details
 Assumes pre-tokenized input:
 \li One token per line
 \li Lines are parsed into TAB-separated fields
 \li Blank lines are interpreted as end-of-sentence (\i EOS)
 \li Input contains raw text only (no markup!)
 \li Comments are introduced with '\%\%', and continue to the end of the line
 \li Word- and sentence-break hints are special comments "\%\%\$WB\$", "\%\%\$SB\$"
 \li Supports multiple tags per token

 \b Format:
<pre>
 FILE       ::= SENTENCE*
 SENTENCE   ::= ((TOKEN|COMMENT)*) "\n"
 TOKEN      ::= TOKEN_TEXT ("\t" LOCATION)? ("\t" ANALYSIS)* ("\r"*) "\n"
 TOKEN_TEXT ::= [^\\t\\r\\n]*
 LOCATION   ::= OFFSET_INT " " LENGTH_INT
 ANALYSIS   ::= (DETAIL*) (COST?) (DETAIL*) "[" TAG ( "]" | " " ) (DETAIL*) (COST?) (DETAIL*)
 DETAIL     ::= [^\\t\\r\\n]
 COST       ::= "<" FLOAT ">"
 COMMENT    ::= "^%%" (.*) "\n"
</pre>
*/

#include <mootToken.h>
#include <mootGenericLexer.h>

using namespace moot;
%}

/*%define FLEX_DEBUG*/

%define CLASS mootTokenLexer

%define INHERIT \
  : public moot::GenericLexer

%define INPUT_CODE \
  return moot::GenericLexer::yyinput(buffer,result,max_size);

%define MEMBERS \
  public: \
  /* -- public typedefs */\
  typedef moot::mootTokenType TokenType; \
  /* extra token types */ \
  static const int LexTypeText = moot::NTokTypes+1;    /* literal token text */ \
  static const int LexTypeTag = moot::NTokTypes+2;     /* analysis tag */ \
  static const int LexTypeDetails = moot::NTokTypes+3; /* analysis details */ \
  static const int LexTypeEOA = moot::NTokTypes+4;     /* end-of-analysis (separator) */ \
  static const int LexTypeEOT = moot::NTokTypes+5;     /* end-of-token */ \
  static const int LexTypeIgnore = moot::NTokTypes+6;  /* ignored data (unused) */ \
  \
  public: \
   /** last token type */ \
   int lasttyp; \
   /** next lexer state */ \
   int nextstate; \
   \
   /* -- pre-allocated construction buffers */ \
   /* current token (default) */ \
   moot::mootToken mtoken_default; \
   /* current token (real) */ \
   moot::mootToken *mtoken; \
   \
   /** current analysis (real) */ \
   moot::mootToken::Analysis *manalysis;\
   \
   /** whether to ignore comments and hints (default=false) */ \
   bool ignore_comments; \
   /** whether first analysis parsed should be considered 'best' (default=true) */ \
   bool first_analysis_is_best; \
   /** whether we're parsing a 'best' analysis */\
   bool current_analysis_is_best; \
   /** whether to (otherwise) ignore first analysis (default=false) */ \
   bool ignore_first_analysis; \
   /** whether to ignore current analysis */\
   bool ignore_current_analysis; \
   /** whether first non-tag analysis should be considered 'location' (default=false) */ \
   bool parse_location; \
   /** whether to parse "<NUMBER>" as analysis cost (default=true) */ \
   bool parse_analysis_cost; \
   /** whether to include parsed costs in analysis details string (default=false) */ \
   bool analysis_cost_details; \
   \
  public: \
    /* -- local methods */ \
    /** virtual destructor to shut up gcc */\
    virtual ~mootTokenLexer(void) {};\
    /** reset to initial state */ \
    virtual void reset(void); \
    /** actions to perform on end-of-analysis */ \
    void on_EOA(void); \
    /** initialize token-buffer location */ \
    inline void loc_set(moot::OffsetT off, int len) \
    { mtoken->location(off,len); } \
    /** add len to token-buffer location length if (!parse_location) */ \
    inline void loc_add(int len) \
    { if (!parse_location) mtoken->loc_length(mtoken->loc_length()+yyleng); } \
    \
  /*-- moot::GenericLexer helpers */ \
  virtual void  *mgl_yy_current_buffer_p(void) \
                 {return reinterpret_cast<void*>(&yy_current_buffer);}; \
  virtual void  *mgl_yy_create_buffer(int size, FILE *unused=stdin) \
                 {return reinterpret_cast<void*>(yy_create_buffer(unused,size));};\
  virtual void   mgl_yy_init_buffer(void *buf, FILE *unused=stdin) \
                 {yy_init_buffer(reinterpret_cast<YY_BUFFER_STATE>(buf),unused);};\
  virtual void   mgl_yy_delete_buffer(void *buf) \
                 {yy_delete_buffer(reinterpret_cast<YY_BUFFER_STATE>(buf));};\
  virtual void   mgl_yy_switch_to_buffer(void *buf) \
                 {yy_switch_to_buffer(reinterpret_cast<YY_BUFFER_STATE>(buf));};\
  virtual void   mgl_begin(int stateno);


%define CONSTRUCTOR_INIT :\
  GenericLexer("mootTokenLexer"), \
  yyin(NULL), \
  lasttyp(moot::TokTypeEOS), \
  nextstate(-1), \
  manalysis(NULL), \
  ignore_comments(false), \
  first_analysis_is_best(true), \
  current_analysis_is_best(false), \
  ignore_first_analysis(false), \
  ignore_current_analysis(false), \
  parse_location(false), \
  parse_analysis_cost(true), \
  analysis_cost_details(false)

  
%define CONSTRUCTOR_CODE \
  mtoken = &mtoken_default;

/*----------------------------------------------------------------------
 * Start States
 *----------------------------------------------------------------------*/
%x LOC_OFFSET
%x LOC_LENGTH
%x TAG
%x DETAILS
%x SEPARATORS
%s TOKEN

/*----------------------------------------------------------------------
 * Definitions
 *----------------------------------------------------------------------*/
space      [ \r]
wordchar   [^ \t\n\r]
tab        [\t]
eoachar    [\t\n\r]
eotchar    [\n\r]
newline    (\r?[\n])
tokchar    [^\t\n\r]
/*detchar    [^ \t\n\r\<\>\[]*/
detchar    [^ \t\n\r\[\<]
tagchar    [^ \t\n\r\]]
anlchar    [^ \t\n\r]
/*bestchar   [\/]*/
costre     (([\+\-]?)([0-9]*)(\.?)([0-9]+)(([eE]([+\-]?)[0-9]+)?))

locsep     [ \r\+]

/*----------------------------------------------------------------------
 * Rules
 *----------------------------------------------------------------------*/
%%
%{
  BEGIN(TOKEN);
  using namespace std;
  using namespace moot;
%}

%{
/*--------------------------------------------------------------------
 * TOKEN
 */
%}

<<EOF>> {
  //-- EOF: should only happen in TOKEN mode
  mtoken->tok_text="";
  switch (lasttyp) {
   case LexTypeText:
   case LexTypeTag:
   case LexTypeDetails:
   case LexTypeEOA:
     on_EOA();
     lasttyp = TokTypeVanilla;
     break;

   case TokTypeUnknown:
   case TokTypeVanilla:
   case TokTypeComment:
   case TokTypeSB:
   case TokTypeWB:
   case TokTypeUser:
     lasttyp = TokTypeEOS;
     break;

   case TokTypeEOS:
     lasttyp = TokTypeEOF;
     break;

   case TokTypeEOF:
     break;

   default:
     lasttyp = TokTypeEOS;
     break;
  }
  mtoken->toktype(static_cast<mootTokenType>(lasttyp));
  return lasttyp;
}

<TOKEN>^{newline} {
  //-- EOS: blank line: maybe return eos (ignore empty sentences) : allow whitespace for WASTE standlone lexer/classifier - moocow Fri, 08 Nov 2013 16:04:25 +0100
  theLine++; theColumn=0; theByte += yyleng;
  if (mtoken->tok_type != TokTypeEOS) {
    mtoken->tok_type=TokTypeEOS;
    mtoken->tok_text="\n";
    if (!parse_location) loc_set(theByte-yyleng, yyleng);
    return TokTypeEOS;
  }
}

<TOKEN>^"%%"([^\r\n]*){newline} {
  //-- COMMENT: return comments as special tokens
  theLine++; theColumn = 0; theByte += yyleng;
  lasttyp = TokTypeComment;
  if (!ignore_comments) {
    mtoken->clear();
    mtoken->toktype(TokTypeComment);
    if (yyleng==7 && yytext[2]=='$' && yytext[4]=='B' &&  yytext[5]=='$') {
      switch (yytext[3]) {
      case 'W': mtoken->toktype(TokTypeWB); break;
      case 'S': mtoken->toktype(TokTypeSB); break;
      default:  break;
      } 
    }
    mtoken->textAppend(reinterpret_cast<const char *>(yytext)+2, yyleng-3);
    if (!parse_location) loc_set(theByte-yyleng, yyleng);
    return lasttyp=mtoken->toktype();
  }
}

<TOKEN>^{tokchar}+ {
  //-- TOKEN-TEXT: allow internal whitespace (for WASTE standlone lexer/classifier - moocow Mon, 04 Nov 2013 10:59:59 +0100)
  add_columns(yyleng);
  mtoken->clear();
  mtoken->toktype(TokTypeVanilla);
  mtoken->text(reinterpret_cast<const char *>(yytext), yyleng);
  if (!parse_location) loc_set(theByte-yyleng, yyleng);
  lasttyp = LexTypeText;
}

<TOKEN>{newline} {
  //-- TOKEN: end-of-token
  add_lines(1);
  mtoken->toktype(TokTypeVanilla);
  loc_add(yyleng); //-- include terminating newline as part of token location
  lasttyp = TokTypeVanilla;
  return TokTypeVanilla;
}

<TOKEN>""/{eoachar} {
  //-- TOKEN: end-of-text (don't trim whitespace for WASTE standlone lexer/classifier - moocow Mon, 04 Nov 2013 10:59:59 +0100)
  if (first_analysis_is_best) {
    current_analysis_is_best = true;
  }
  if (parse_location) {
    nextstate = LOC_OFFSET;
  }

  if (ignore_first_analysis) ignore_current_analysis = true;

  lasttyp = LexTypeText;
  BEGIN(SEPARATORS);
}


%{
/*--------------------------------------------------------------------
 * SEPARATORS
 */
%}

<SEPARATORS>{tab}({space}*) {
  //-- SEPARATORS: Separator character(s): increment column nicely
  theColumn = (static_cast<int>(theColumn/8)+1)*8;
  theByte += yyleng;
  loc_add(yyleng);
  lasttyp = LexTypeEOA;
}
<SEPARATORS>""/{wordchar} {
  //-- SEPARATORS: end of separators
  theColumn += yyleng;
  theByte += yyleng;
  //-- maybe switch to new start-state
  if (nextstate >= 0) {
    BEGIN(nextstate); //-- be sure to re-set nextstate=-1 in nextstate!
  } 
  else {
    //-- allocate new analysis
    mtoken->insert(mootToken::Analysis());
    manalysis = &(mtoken->tok_analyses.back());
    BEGIN(DETAILS); 
  }
}
<SEPARATORS>""/{eotchar} {
  //-- SEPARATORS/EOT: reset to initial state
  //theLine++;
  //theColumn = 0;
  //theByte += yyleng;
  nextstate = -1;
  BEGIN(TOKEN);
}


%{
/*--------------------------------------------------------------------
 * DETAILS
 */
%}

<DETAILS>"["_?/{tagchar} {
  //-- DETAILS: looks like a tag
  add_columns(yyleng);
  loc_add(yyleng);
  manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  lasttyp = LexTypeDetails;
  BEGIN(TAG);
}

<DETAILS>{space}+/"<"{costre}">" {
  //-- DETAILS: pre-cost space
  add_columns(yyleng);
  loc_add(yyleng);
  if (analysis_cost_details) {
    manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  }
  lasttyp = LexTypeDetails;
}

<DETAILS>"<"{costre}">" {
  //-- DETAILS: cost (clobber manalysis->prob)
  add_columns(yyleng);
  loc_add(yyleng);
  if (parse_analysis_cost) {
    manalysis->prob = strtof (reinterpret_cast<const char *>(yytext)+1, NULL);
  }
  if (analysis_cost_details) {
    manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  }
  lasttyp = LexTypeDetails;
}

<DETAILS>[\<\>\[] {
  //-- allow <,>,[ in details strings even without valid cost or tag
  add_columns(yyleng);
  loc_add(yyleng);
  manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  lasttyp = LexTypeDetails;
}

<DETAILS>{detchar}+ {
  //-- DETAILS: detail text
  add_columns(yyleng);
  loc_add(yyleng);
  manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  lasttyp = LexTypeDetails;
}

<DETAILS>{space}+/{wordchar} {
  //-- DETAILS: internal whitespace: keep it
  add_columns(yyleng);
  loc_add(yyleng);
  manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  lasttyp = LexTypeDetails;
}

<DETAILS>{space}*/{eoachar} {
  //-- DETAILS/EOA: add & clear current analysis, if any
  add_columns(yyleng);
  loc_add(yyleng);
  on_EOA();
  BEGIN(SEPARATORS);
}

%{
/*--------------------------------------------------------------------
 * TAG
 */
%}

<TAG>{tagchar}+ {
  //-- TAG: tag text
  add_columns(yyleng);
  loc_add(yyleng);
  manalysis->details.append(reinterpret_cast<const char *>(yytext), yyleng);
  if (manalysis->tag.empty()) manalysis->tag.assign(reinterpret_cast<const char *>(yytext), yyleng);
  lasttyp = LexTypeTag;
  BEGIN(DETAILS);
}

%{
/*--------------------------------------------------------------------
 * LOCATION
 */
%}

<LOC_OFFSET>[0-9]+ {
  //-- LOCATION: offset
  add_columns(yyleng);
  mtoken->loc_offset(strtoul(reinterpret_cast<const char *>(yytext),NULL,0));
  BEGIN(LOC_LENGTH);
}

<LOC_LENGTH>[0-9]+ {
  //-- LOCATION: length
  add_columns(yyleng);
  mtoken->loc_length(strtoul(reinterpret_cast<const char *>(yytext),NULL,0));
}

<LOC_OFFSET,LOC_LENGTH>{space}+ { add_columns(yyleng); }
<LOC_OFFSET,LOC_LENGTH>""/{eotchar} { nextstate=-1; BEGIN(TOKEN); }
<LOC_OFFSET,LOC_LENGTH>""/. { nextstate=-1; BEGIN(SEPARATORS); }


%{
/*--------------------------------------------------------------------
 * UNKNOWN
 */
%}

{space}+ {
  /* mostly ignore spaces */
  add_columns(yyleng);
  loc_add(yyleng);
  //lasttyp = LexTypeIgnore;
}

. {
  add_columns(yyleng);
  loc_add(yyleng);
  yycarp("Unrecognized TOKEN character '%c'", *yytext);
}

<DETAILS>. {
  add_columns(yyleng);
  loc_add(yyleng);
  yycarp("Unrecognized DETAIL character '%c'", *yytext);
}

<TAG>. {
  add_columns(yyleng);
  loc_add(yyleng);
  yycarp("Unrecognized TAG character '%c'", *yytext);
}

%%

/*----------------------------------------------------------------------
 * mootTokenLexer helpers
 */
void mootTokenLexer::mgl_begin(int stateno) {BEGIN(stateno);}

/*----------------------------------------------------------------------
 * Local Methods for mootTokenLexer
 *----------------------------------------------------------------------*/
void mootTokenLexer::reset(void)
{
  theLine = 0;
  theColumn = 0;
  theByte = 0;
  current_analysis_is_best = false;
  manalysis = NULL;
  mtoken_default.clear();
  lasttyp = moot::TokTypeEOS;
  BEGIN(TOKEN);
}

void mootTokenLexer::on_EOA(void)
{
  /*-- EOA: add & clear current analysis, if any */ 
  /*-- add & clear current analysis, if any */ 
  if (manalysis && lasttyp != LexTypeEOA) { 
    /*-- set default tag */
    if (manalysis->tag.empty()) { 
      size_t tag_begin = manalysis->details.find_first_not_of(" []<>\n\r",0);
      size_t tag_end   = manalysis->details.find_first_of(" []<>\n\r",tag_begin);
      if (tag_begin != std::string::npos && tag_end != std::string::npos) {
	manalysis->tag.assign(manalysis->details,tag_begin,tag_end);
      } else {
	manalysis->tag.assign(manalysis->details);
      }
    }  
    /* set best tag if applicable */
    if (current_analysis_is_best) { 
      mtoken->besttag(manalysis->tag); 
      current_analysis_is_best = false; 
      //if (parse_location) { nextstate=LOC_OFFSET; }
    }
    /* maybe ignore this analysis */ 
    if (ignore_current_analysis) { 
      ignore_current_analysis=false; 
      mtoken->tok_analyses.pop_back(); 
    } 
  } 
}; 
