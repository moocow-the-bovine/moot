.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MOOTFILES 5"
.TH MOOTFILES 5 "2009-04-24" "moot v2.0.6" "moot PoS Tagger"
.SH "moot FILE FORMATS"
.IX Header "moot FILE FORMATS"
This manpage describes various file formats used by the
moot PoS tagging utilities.
.SH "PROGRAM CONFIGURATION FILES"
.IX Header "PROGRAM CONFIGURATION FILES"
Most moot utility programs support global and user-specific
configuration files which can be used to set system defaults
and/or user preferences for values of program options.
.PP
Configuration files are expected to contain lines of the form:
.PP
.Vb 1
\& LONG_OPTION_NAME    OPTION_VALUE
.Ve
.PP
where \s-1LONG_OPTION_NAME\s0 is the long name of one of the
program's options, without the leading '\-\-', and
\&\s-1OPTION_VALUE\s0 is the value for that option, if any.
Fields are whitespace\-separated.
Blank lines and comments (lines beginning with a '#' character)
are ignored.
.PP
The following configuration files are read by default,
where ${\s-1PROGNAME\s0} is the name of a moot utility program,
and ${\s-1HOME\s0} is the home directory of the current user:
.IP "/etc/${\s-1PROGNAME\s0}rc" 4
.IX Item "/etc/${PROGNAME}rc"
System defaults file; read first.
.IP "${\s-1HOME\s0}/.${\s-1PROGNAME\s0}rc" 4
.IX Item "${HOME}/.${PROGNAME}rc"
User preferences file, can be used to override system defaults.
.PP
Any options specified on the command-line override
defaults from a program configuration file.
.SH "TEXT FILE FORMATS (NATIVE)"
.IX Header "TEXT FILE FORMATS (NATIVE)"
.Sh "Raw Text Files"
.IX Subsection "Raw Text Files"
A \*(L"raw\*(R" text file is just that: any file consiting of (8\-bit)
characters.  Such files may be processed by the mootpp
preprocessor to produce \*(L"rare cooked\*(R" (\-tagged, \-analyzed)
text files.  An example \*(L"raw\*(R" text file is:
.PP
.Vb 1
\& This is a test.  This too.
.Ve
.Sh "Cooked Text Files"
.IX Subsection "Cooked Text Files"
A \*(L"cooked\*(R" text file is a text file which encodes information
such as token boundaries, sentence boundaries, part-of-speech tag,
and/or potential analyses.  The moot utilities distinguish between
several different types of cooked text file: in order of ascending
informational content, these are:
\&\*(L"rare\*(R" (\-tagged, \-analyzed),
\&\*(L"medium rare\*(R" (\-tagged, +analyzed),
\&\*(L"medium\*(R" (+tagged, \-analyzed),
\&\*(L"well done\*(R" (+tagged, +analyzed),
and
\&\*(L"refried\*(R" (+tagged, +analyzed, +evaluated).
Differnent moot utilities require their input files to be
more or less \*(L"cooked\*(R" \*(-- see the documentation of the individual
utilities for details.
.PP
Native \*(L"cooked\*(R" text files are conventionally
identified by the filename infix \*(L".moot\*(R".
.IP "Rare" 4
.IX Item "Rare"
.PD 0
.IP "(\-tagged, \-analyzed)" 4
.IX Item "(-tagged, -analyzed)"
.IP "Files: *.t, *.r, *.rt" 4
.IX Item "Files: *.t, *.r, *.rt"
.PD
The most basic level of \*(L"cookedness\*(R", a \*(L"rare\*(R" text file encodes
only token\- and sentence\-boundaries.
By convention, \*(L"rare\*(R"
filenames carry the extension \*(L".t\*(R".  The syntax is:
.Sp
.Vb 9
\& RARE_FILE  ::= {RARE_LINE}*
\& RARE_LINE  ::= ({COMMENT} | {EOS} | {RARE_TOKEN}) {NEWLINE}
\& COMMENT    ::= {SPACE}* "%%" ([^{NEWLINE}])*
\& EOS        ::= ( {SPACE}* {NEWLINE} )+
\& RARE_TOKEN ::= {TOKEN_TEXT}
\& TOKEN_TEXT ::= ( {WORDCHAR} | {SPACE} )+
\& SPACE      ::= " "
\& NEWLINE    ::= "\en" | "\er"
\& WORDCHAR   ::= [^{SPACE}{NEWLINE}]
.Ve
.Sp
Leading and trailing spaces are stripped from token text; it is
thus impossible to declare an \*(L"empty\*(R" token.  An example
\&\*(L"rare cooked\*(R" file is:
.Sp
.Vb 7
\& %% Example rare cooked file for moot
\& %% Sentence 1
\& This
\& is
\& a
\& test
\& .
.Ve
.Sp
.Vb 4
\& %% Sentence 2
\& This
\& too
\& .
.Ve
.IP "Medium Rare" 4
.IX Item "Medium Rare"
.PD 0
.IP "(\-tagged, +analyzed)" 4
.IX Item "(-tagged, +analyzed)"
.IP "Files: *.mr, *.mrt" 4
.IX Item "Files: *.mr, *.mrt"
.PD
A \*(L"medium rare\*(R" file is at least as informative as a \*(L"rare\*(R"
file \*(-- that is, it encodes everything that a \*(L"rare\*(R" file
encodes, and in exactly the same fashion.  Additionally,
a \*(L"medium rare\*(R" file may contain for each token a set
of (TAB\-separated) possible \fIanalyses\fR for that token, where
an \*(L"analysis\*(R" contains at least a part-of-speech tag, and possibly
also a numeric cost and arbitrary analysis details.
Somewhat counter\-intuitively,
every \*(L"rare\*(R" file is also a \*(L"medium rare\*(R" file for which
every token is associated with an empty set of possible analyses.
By convention, \*(L"medium rare\*(R" filenames carry the extension \*(L".mrt\*(R"
.Sp
.Vb 10
\& MED_RARE_FILE  ::= {MED_RARE_LINE}*
\& MED_RARE_LINE  ::= ({COMMENT} | {EOS} | {MED_RARE_TOKEN}) {NEWLINE}
\& MED_RARE_TOKEN ::= {TOKEN_TEXT} ( {TAB} {ANALYSIS} )*
\& ANALYSIS       ::= {DETAIL_PREFIX}? {TAG} {DETAIL_SUFFIX}?
\& DETAIL_PREFIX  ::= ( {WORDCHAR} | {SPACE} | {COST} )* ("[" ("_"?))?
\& COST           ::= "<" ("\-"|"+")? ([0\-9]* ".")? [0\-9]+ ">"
\& TAG            ::= {TAGCHAR}+
\& DETAIL_SUFFIX  ::= ( {WORDCHAR} | {SPACE} | {COST} )*
\& TAGCHAR        ::= [^{SPACE}{TAB}{NEWLINE}"]"]
\& TAB            ::= "\et"
.Ve
.Sp
Leading and trailing spaces are stripped from token text,
as well as from analysis-detail and \-tag text.  It should
be noted that the \fI\s-1TAG\s0\fR component of each \fI\s-1ANALYSIS\s0\fR
is \*(L"greedy\*(R" \*(-- if an
analysis contains no left-bracket to mark the beginning
of a tag, then the whole analysis (up to the first right-bracket
or space) is considered the tag.  Also, if the analysis
contains multiple left\-brackets, only the \fIfirst\fR is
considered to introduce the \fI\s-1TAG\s0\fR component.
An example \*(L"medium rare\*(R" file is:
.Sp
.Vb 7
\& %% Example medium\-rare cooked file for moot
\& %% Sentence 1 : possible analyses are tags only
\& This   NE      PDAT    PDIS
\& is     VAFIN   VVFIN
\& a      ART     CARD
\& test   NN      VVIN
\& .      $.
.Ve
.Sp
.Vb 4
\& %% Sentence 2 : detailed analyses, with unknown word "foo".
\& This   This [NE type="name"] <420>      <24.7> this [_PDAT][_sg]
\& foo
\& .      . [$.] <\-42>
.Ve
.Sp
Tokens in \*(L"medium rare\*(R" files with empty analysis sets
(i.e. \fI\s-1RARE_TOKEN\s0\fRs)
are called \*(L"unrecognized\*(R" tokens.
.IP "Medium" 4
.IX Item "Medium"
.PD 0
.IP "(+tagged, \-analyzed)" 4
.IX Item "(+tagged, -analyzed)"
.IP "Files: *.tt, *.ttt, *.m, *.mt" 4
.IX Item "Files: *.tt, *.ttt, *.m, *.mt"
.PD
A \*(L"medium\*(R" file can be understood as a \*(L"medium rare\*(R" file which
associates exactly one analysis with each token.  The tag for this
analysis is considered the \*(L"best\*(R" tag for the associated token.
By convention, \*(L"medium\*(R" filenames carry the extension \*(L".tt\*(R"
(tagger output) or \*(L".ttt\*(R" (gold standard).
.Sp
.Vb 4
\& MEDIUM_FILE    ::= {MEDIUM_LINE}*
\& MEDIUM_LINE    ::= ({COMMENT} | {EOS} | {MEDIUM_TOKEN}) {NEWLINE}
\& MEDIUM_TOKEN   ::= {TOKEN_TEXT} {TAB} {BEST_ANALYSIS}
\& BEST_ANALYSIS  ::= {ANALYSIS}
.Ve
.Sp
As before, leading and trailing spaces are stripped from
token text and analyses, and the \fI\s-1TAG\s0\fR component of each
\&\fI\s-1ANALYSIS\s0\fR is \*(L"greedy\*(R".
An example \*(L"medium\*(R" file is:
.Sp
.Vb 7
\& %% Example medium cooked file for moot
\& %% Sentence 1 : best analyses are tags only
\& This   PDAT
\& is     VVFIN
\& a      ART
\& test   NN
\& .      $.
.Ve
.Sp
.Vb 4
\& %% Sentence 2 : tags embedded in detailed analyses
\& This   <24.7> this [PDAT num="sg"]
\& too    <0.0> too [ADV]
\& .      <\-42> . [$.]
.Ve
.IP "Well Done" 4
.IX Item "Well Done"
.PD 0
.IP "(+tagged, +analyzed)" 4
.IX Item "(+tagged, +analyzed)"
.IP "Files: *.wd, *.wdt" 4
.IX Item "Files: *.wd, *.wdt"
.PD
A \*(L"well done\*(R" file can be understood as the synthesis of
a \*(L"medium rare\*(R" and a \*(L"medium\*(R" file: it contains a \*(L"best\*(R"
analysis for each token (the first one), as well as a set of
\&\fIa priori\fR potential analyses analyses for that token.
By convention, \*(L"well done\*(R" filenames carry the extension \*(L".wd\*(R"
(tagger output) or \*(L".wdt\*(R" (gold standard).
.Sp
.Vb 3
\& WELL_DONE_FILE  ::= {WELL_DONE_LINE}*
\& WELL_DONE_LINE  ::= ({COMMENT} | {EOS} | {WELL_DONE_TOKEN}) {NEWLINE}
\& WELL_DONE_TOKEN ::= {TOKEN_TEXT} {TAB} {BEST_ANALYSIS} ( {TAB} {ANALYSIS} )*
.Ve
.Sp
As before, leading and trailing spaces are stripped from
token text and analyses, and the \fI\s-1TAG\s0\fR component of each
\&\fI\s-1ANALYSIS\s0\fR is \*(L"greedy\*(R".
An example \*(L"well done\*(R" file is:
.Sp
.Vb 7
\& %% Example well\-done cooked file for moot
\& %% Sentence 1 : analysis\-set tags bracketed for clarity
\& This   PDAT    [NE]    [PDAT]    [PDIS]
\& is     VVFIN   [VAFIN] [VVFIN]
\& a      ART     [ART]   [CARD]
\& test   NN      [NN]    [VVFIN]
\& .      $.      [$.]
.Ve
.Sp
.Vb 4
\& %% Sentence 2 : analysis\-tags embedded in complete analyses
\& This   PDAT    [NE type="last"] This <420>  [PDAT num="sg"] this <24.7>
\& too    ADV     [ADV] too <0.0>
\& .      $.      [$.] . <\-42>
.Ve
.IP "Refried" 4
.IX Item "Refried"
.PD 0
.IP "(+tagged, +analyzed, +evaluated)" 4
.IX Item "(+tagged, +analyzed, +evaluated)"
.PD
A \*(L"refried\*(R" file is basically the synthesis of a pair of
\&\*(L"medium\*(R" or \*(L"well done\*(R" files.  \*(L"Refried\*(R" files can be
created by the \fImooteval\fR program from a pair of
parallel cooked files.  Each line of a \*(L"refried\*(R" file
contains an status code, and a pair of \*(L"well\-done\*(R" style token
analyses separated by tabs and a single slash '/'.
.Sp
.Vb 14
\& REFRIED_FILE     ::= {REFRIED_LINE}*
\& REFRIED_LINE     ::= ( {COMMENT} | {EOS} | {REFRIED_TOKEN} ) {NEWLINE}
\& REFRIED_TOKEN    ::= {STATUS_CODE} {TAB} {REFRIED_SOURCES}
\& REFRIED_SOURCES  ::= {WELL_DONE_TOKEN} {TAB} "/" {TAB} {WELL_DONE_TOKEN}
\& STATUS_CODE      ::= {BASIC_FLAGS} ":" {FILE1_FLAGS} ":" {FILE2_FLAGS}
\& BASIC_FLAGS      ::= {TOKMATCH_FLAG} {BESTMATCH_FLAG}
\& TOKMATCH_FLAG    ::= "\-" | "t"
\& BESTMATCH_FLAG   ::= "\-" | "b"
\& FILE1_FLAGS      ::= {FILE_FLAGS}
\& FILE2_FLAGS      ::= {FILE_FLAGS}
\& FILE_FLAGS       ::= {EMPTY_FLAG} {IMPOSSIBLE_FLAG} {XIMPOSSIBLE_FLAG}
\& EMPTY_FLAG       ::= "\-" | "e"
\& IMPOSSIBLE_FLAG  ::= "\-" | "i"
\& XIMPOSSIBLE_FLAG ::= "\-" | "x"
.Ve
.Sp
As before, leading and trailing spaces are stripped from
token text and analyses, and the \fI\s-1TAG\s0\fR component of each
\&\fI\s-1ANALYSIS\s0\fR is \*(L"greedy\*(R".
.Sp
The \s-1STATUS_CODE\s0 component of each \s-1REFRIED_TOKEN\s0 encodes a
number of flags concerning which part (if any) of the
tokens compared did not match.  The general convention
is use of a '\-' character to indicate that the compared
tokens matched (or at least were compatible).
.RS 4
.IP "\s-1TOKMATCH_FLAG\s0" 4
.IX Item "TOKMATCH_FLAG"
\&'\-' if token text components matched, otherwise 't'.
.IP "\s-1BESTMATCH_FLAG\s0" 4
.IX Item "BESTMATCH_FLAG"
\&'\-' if best-tag components matched, otherwise 'b'.
.IP "\s-1EMPTY_FLAG\s0" 4
.IX Item "EMPTY_FLAG"
\&'\-' if token \s-1ANALYSES\s0 were non-empty (for the given file), otherwise 'e'.
.IP "\s-1IMPOSSIBLE_FLAG\s0" 4
.IX Item "IMPOSSIBLE_FLAG"
\&'\-' if token \s-1ANALYSES\s0 included token \s-1BESTTAG\s0 (for the corresponding file), otherwise 'i'.
.IP "\s-1XIMPOSSIBLE_FLAG\s0" 4
.IX Item "XIMPOSSIBLE_FLAG"
\&'\-' if token \s-1ANALYSES\s0 included token \s-1BESTTAG\s0 for the \fBother\fR file, otherwise 'x'.
.RE
.RS 4
.Sp
An example \*(L"refried\*(R" file is:
.Sp
.Vb 8
\& %% Example refried file for moot
\& %% FLAGS       TOK1    TOK1TAG1 ...            /       TOK2    TOK2TAG1 ...
\& %%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& t\-:\-\-\-:\-\-\-     Dis     PDAT    [PDAT]  [PDIS]  /       This    PDAT    [PDAT]  [PDIS]
\& \-b:\-\-\-:\-\-\-     is      VAFIN   [VAFIN] [VVFIN] /       is      VVFIN   [VAFIN] [VVFIN]
\& \-\-:e\-\-:\-\-\-     a       ART     /       a       ART     [ART]   [CARD]
\& \-b:\-i\-:\-\-\-     test    NN      [VVFIN] /       test    VVFIN   [NN]    [VVFIN]
\& \-\-:\-\-\-:\-\-\-     .       $.      [$.]    /       .       $.      [$.]
.Ve
.Sp
.Vb 3
\& \-b:\-\-x:\-\-\-     This    PDAT    [PDAT]  /       This    PDIS    [PDAT]  [PDIS]
\& \-\-:\-\-\-:\-ix     too     ADV     [ADV]   [PTKA]  /       too     ADV     [CONJ]
\& \-\-:\-\-\-:e\-\-     .       $.      [$.]    /       .       $.
.Ve
.Sp
Re-formatting for better human readabilty produces:
.Sp
.Vb 8
\& %% Example refried file for moot
\& %% FLAGS       TOK1    TOK1TAG1 ...            /       TOK2    TOK2TAG1 ...
\& %%\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& t\-:\-\-\-:\-\-\-     Dis     PDAT    [PDAT]  [PDIS]  /       This    PDAT    [PDAT]  [PDIS]
\& \-b:\-\-\-:\-\-\-     is      VAFIN   [VAFIN] [VVFIN] /       is      VVFIN   [VAFIN] [VVFIN]
\& \-\-:e\-\-:\-\-\-     a       ART                     /       a       ART     [ART]   [CARD]
\& \-b:\-i\-:\-\-\-     test    NN      [VVFIN]         /       test    VVFIN   [NN]    [VVFIN]
\& \-\-:\-\-\-:\-\-\-     .       $.      [$.]            /       .       $.      [$.]
.Ve
.Sp
.Vb 3
\& \-b:\-\-x:\-\-\-     This    PDAT    [PDAT]          /       This    PDIS    [PDAT]  [PDIS]
\& \-\-:\-\-\-:\-ix     too     ADV     [ADV]   [PTKA]  /       too     ADV     [CONJ]
\& \-\-:\-\-\-:e\-\-     .       $.      [$.]            /       .       $.
.Ve
.RE
.SH "XML FILE FORMATS"
.IX Header "XML FILE FORMATS"
moot currently uses the (extremely cool and amazingly fast)
Expat \s-1XML\s0 parser library by James Clark for incremental
processing of \s-1XML\s0 documents, (a previous implementation
used libxml2 (also extremely cool but not quite as amazingly fast as expat),
but the moot libxml2 support is no longer maintained, and is disabled
by default), as well as output recoding
using librecode by François Pinard.  Both expat and
librecode support are compile-time options \*(-- check
the contents of 'mootConfig.h' to see whether they
are enabled on your system.
.PP
When working with \*(L"cooked\*(R" \s-1XML\s0 (see below), it is
critical to remember that the moot internal processing
routines \fBalways\fR receive token and PoS-tag text encoded
in \s-1UTF\-8\s0, \fIregardless\fR of the document encoding.
This is of particular importance when converting
from native to \s-1XML\s0 format i.e. with 'mootchurn'
\&\*(-- it is highly reccommended that you use the 'recode'
command-line utility (distributed with 'librecode')
to ensure that your native text data
is true \s-1UTF\-8\s0 before passing it to 'mootchurn' for \s-1XML\s0
output.
.PP
Similarly, \s-1HMM\s0 model data (see \*(L"\s-1HMM\s0 \s-1MODEL\s0 \s-1FILE\s0 \s-1FORMATS\s0\*(R")
\&\fBmust\fR be \s-1UTF\-8\s0 encoded for
tagging in \s-1XML\s0 mode.  There is currently no way to
directly convert the encoding of a binary model file,
but text model files can be converted with the 'recode'
command-line utility.
.PP
Future implementations might use locale
information to (partially) automate the recoding process.
If all of your data (training corpus, test corpus,
and runtime corpora) are parsed in \s-1XML\s0 mode,
none of the above should present a problem.
.PP
\&\s-1XML\s0 files are identified by the filename infix '.xml'.
.Sh "Raw \s-1XML\s0 Files"
.IX Subsection "Raw XML Files"
A \*(L"raw\*(R" \s-1XML\s0 file is just like a \*(L"raw\*(R" text file.  The
\&'mootpp' program supports rudimentary recognition and
removal of (SG|HT|X)ML markup.
.Sh "Cooked \s-1XML\s0 Files"
.IX Subsection "Cooked XML Files"
As of version 2.0.0, the moot utilities
support \*(L"cooked\*(R" \s-1XML\s0 files, in addition to the native
text format(s).  See \*(L"Cooked Text Files\*(R" above for
more details on the native formats and the
information content corresponding to the various
subtypes.
.PP
All \*(L"cooked\*(R" \s-1XML\s0 formats share the same structure (much
as the \*(L"cooked\*(R" text formats are defined in terms of
one another).  The preliminary syntax (subject to change
without notice) is:
.PP
.Vb 14
\& COOKED_XML_FILE    ::= {XML_DECL}? {XML_CONTENT}*
\& XML_DECL           ::= "<?xml " ... "?>"
\& XML_CONTENT        ::= {XML_EOS} | {XML_RAW} | {XML_TOKEN}
\& XML_EOS            ::= "<eos/>"
\& XML_RAW            ::= ...
\& XML_TOKEN          ::= "<token>" {XML_TOKEN_CONTENT} "</token>"
\& XML_TOKEN_CONTENT  ::= ({XML_TOKEN_TEXT}
\&                         | {XML_TOKEN_ANALYSIS}
\&                         | {XML_TOKEN_BESTTAG}
\&                         | {XML_RAW})*
\& XML_TOKEN_TEXT     ::= "<text>" {TOKEN_TEXT} "</text>"
\& XML_TOKEN_BESTTAG  ::= "<moot.tag>" {TOKEN_BESTTAG} "</moot.tag>"
\& XML_TOKEN_ANALYSIS ::= \(aq<analysis pos="\(aq {ANALYSIS_TAG} \(aq">\(aq {ANALYSIS_DETAILS} "</analysis>"
\& ANALYSIS_DETAILS   ::= {XML_RAW}*
.Ve
.PP
The document structure is thus expected to be something like
the following (in a bastard notation born of \s-1BNF\s0 and XPath):
.PP
.Vb 5
\& SENTENCE_BOUNDARY  ::= //eos                            # really only end\-elts
\& TOKEN_TEXT         ::= //token//text/text()             # should be accurate
\& ANALYIS_TAG        ::= //token//analysis/@pos           # uses attribute value (not full node)
\& ANALYSIS_DETAILS   ::= //token//analysis/text()         # buggy \-\- actually ignored!
\& TOKEN_BESTTAG      ::= //token//moot.tag[last()]/text() # should be accurate
.Ve
.PP
Contact the author if you need any of the following done:
.IP "\s-1TODO\s0" 4
.IX Item "TODO"
Pull up literal element name parameters from TokenReaderExpat
to user\-level.
.IP "\s-1TODO\s0" 4
.IX Item "TODO"
Add a \s-1DTD\s0 for the default \s-1XML\s0 format to the distribution.
.PP
An example \*(L"cooked\*(R" \s-1XML\s0 document is the following:
.PP
.Vb 46
\& <?xml version="1.0"?>
\& <doc>
\&  <!\-\- Sentence\-1 : Well Done, Medium, and Medium Rare \-\->
\&  <token>
\&    <!\-\- A \(aqwell done\(aq token with minimal structure \-\->
\&    <text>This</text>
\&    <moot.tag>PDAT</moot.tag>
\&    <analysis pos="NE"/>
\&    <analysis pos="NN"/>
\&    <analysis pos="PDAT"/>
\&    <analysis pos="PDS"/>
\&  </token>
\&  <token>
\&    <!\-\- A \(aqwell done\(aq token with extra structure \-\->
\&    <text>is</text>
\&    <extraneous.element>
\&      <analysis pos="VAFIN"/>
\&      <moot.tag>VVFIN</moot.tag>
\&      <analysis pos="VVFIN"/>
\&    </extraneous.element>
\&  </token>
\&  <token>
\&    <!\-\- Yet another \(aqwell done\(aq token  \-\->
\&    <text>a</text>
\&    <other_extraneous_element>
\&      <analysis pos="ART"/>
\&    </other_extraneous_element>
\&    <moot.tag>ART</moot.tag>
\&  </token>
\&  <token>
\&    <!\-\- A \(aqmedium\(aq token \-\->
\&    <text>Test</text>
\&    <moot.tag>NN</moot.tag>
\&  </token>
\&  <token>
\&    <!\-\- A \(aqMedium Rare\(aq token \-\->
\&    <text>.</text>
\&    <analysis pos="$."/>
\&  </token>
\&  <eos/>
\&  <!\-\- Sentence\-2 : Rare tokens only \-\->
\&  <token><text>This</text></token>
\&  <token><text>too</text></token>
\&  <token><text>.</text></token>
\&  <eos/>
\& </doc>
.Ve
.Sh "I/O Format Flags"
.IX Subsection "I/O Format Flags"
Several moot utilities are capable of processing input
in a number of different formats, typically specified
by '\-\-input\-format' (\-I) and '\-\-output\-format' (\-O) command-line options
The following list briefly describes the (case\-insensitive)
format flags which may occur as individual elements of the
comma-separated list passed as an argument to these format options.
Each format flag may be preceeded by an exclamation point \*(L"!\*(R" to indicate
the negation of the respective format property.
Note that at the current time, not all formats support
all available flags.
.PP
If no format flags are specified by the user, the
moot utilities will attempt to guess an appropriate
format based on the filename and on the requirements
for the particular utility in question.
.IP "Basic Flags" 4
.IX Item "Basic Flags"
.RS 4
.PD 0
.IP "None" 4
.IX Item "None"
.PD
No flags at all.
This should never really happen at runtime,
and should cause a default format to be assumed
and/or an appropriate format to be guessed from
the relevant filename(s).
.IP "Null" 4
.IX Item "Null"
If you specify 'null' as an output format,
no output will actually be written
(useful for testing and benchmarking the input layer).
.IP "Unknown" 4
.IX Item "Unknown"
Unknown format.
This should never ever happen,
and should cause a reversion to some default format.
.IP "Native" 4
.IX Item "Native"
Specifies native text format I/O, as opposed to \s-1XML\s0.
.IP "\s-1XML\s0" 4
.IX Item "XML"
Specifies \s-1XML\s0 format I/O, as opposed to a native text format.
.IP "Pretty" 4
.IX Item "Pretty"
Beautified \s-1XML\s0 format.
Useful for human-readable \s-1XML\s0 output.
Not all \s-1XML\s0 I/O modes support cosmetic surgery.
.IP "Conserve" 4
.IX Item "Conserve"
Conservative \s-1XML\s0 format: attempt to preserve as
much of the input document structure as possible.
Only meaningful if both \s-1XML\s0 input and \s-1XML\s0 output
are requested.
.IP "Text" 4
.IX Item "Text"
Read/write token text (all formats).
.IP "Analyzed" 4
.IX Item "Analyzed"
Read/write token analyses ('medium rare' or 'well done' formats only).
.IP "Tagged" 4
.IX Item "Tagged"
Read/write 'best tags' ('medium' or 'well done' formats only).
.IP "Location" 4
.IX Item "Location"
Read/write token locations as logical pairs (\s-1BYTE_OFFSET\s0,BYTE_LENGTH)
from/to the input stream as the first non-tag analysis.
Useful if you need to refer back to earlier stages of a token processing pipeline.
.IP "Pruned" 4
.IX Item "Pruned"
For 'well done' formats, ignore analyses which do
not correspond to the 'best' tag.
.RE
.RS 4
.RE
.IP "Compound Flags" 4
.IX Item "Compound Flags"
.RS 4
.PD 0
.IP "Rare" 4
.IX Item "Rare"
.IP "R" 4
.IX Item "R"
.PD
Alias for 'Text'.
.IP "MediumRare" 4
.IX Item "MediumRare"
.PD 0
.IP "\s-1MR\s0" 4
.IX Item "MR"
.PD
Alias for 'Text,Analyzed'.
.IP "Medium" 4
.IX Item "Medium"
.PD 0
.IP "M" 4
.IX Item "M"
.PD
Alias for 'Text,Tagged'.
.IP "WellDone" 4
.IX Item "WellDone"
.PD 0
.IP "\s-1WD\s0" 4
.IX Item "WD"
.PD
Alias for 'Text,Tagged,Analyzed'
.RE
.RS 4
.RE
.IP "Examples" 4
.IX Item "Examples"
.RS 4
.PD 0
.IP "*" 4
.PD
Read input as native rare text (tokens only), write output as
medium (best\-tagged) native text:
.Sp
.Vb 1
\& moot \-\-input\-format=native,text \-\-output\-format=native,text,tagged
.Ve
.Sp
Same thing, only shorter:
.Sp
.Vb 1
\& moot \-\-input\-format=rare \-\-output\-format=medium
.Ve
.Sp
Same thing, even shorter:
.Sp
.Vb 1
\& moot \-Ir \-Om
.Ve
.Sp
Same thing, using filename conventions:
.Sp
.Vb 1
\& moot input.moot.t \-o output.moot.tt
.Ve
.IP "*" 4
Read medium rare (pre\-analyzed) \s-1XML\s0, write well-done native text:
.Sp
.Vb 1
\& moot \-I xml,mediumrare \-O native,welldone
.Ve
.Sp
Same thing, using filename conventions:
.Sp
.Vb 1
\& moot input.mr.xml \-o output.wd.moot
.Ve
.RE
.RS 4
.RE
.SH "HMM MODEL FILE FORMATS"
.IX Header "HMM MODEL FILE FORMATS"
The \fImoothmm\fR\|(1) program can use either text\- or native
binary-format model files, which encode raw frequency counts
(text model files), or probability tables and compile-time
flags for the Hidden Markov Model (binary model files),
respectively.
.Sh "Text Models"
.IX Subsection "Text Models"
A \*(L"Text Model\*(R" is completely specified by
three files: a lexical freqency file (*.lex), an n\-gram frequency
file (*.123), and an optional lexical-class frequency file (*.clx).
.PP
When specifiying a text model name to a moot utility program,
you may specify the model name as \fI\s-1TMODEL\s0\fR in order to use the
files \fI\s-1TMODEL\s0\fR.lex , \fI\s-1TMODEL\s0\fR.123 , and \fI\s-1TMODEL\s0\fR.clx (if present).
Otherwise, you may specifiy a composite model name as
a comma-separated list of the individual component filenames:
\&\fImylex.lex,myngrams.123,myclasses.clx\fR.
.IP "\fBLexical Frequency Files\fR" 4
.IX Item "Lexical Frequency Files"
Lexical frequency files store raw frequencies for known tokens
and (token,tag) pairs.  The format use is ca. 99.998% compatible
with that generated by the \fItnt\-para\fR\|(1) program:
.Sp
.Vb 18
\& LEX_FILE    ::= ({COMMENT} | {BLANK_LINE} | {LEX_ENTRY})*
\& COMMENT     ::= {SPACE}* "%%" ([^{NEWLINE}])*  {NEWLINE}
\& BLANK_LINE  ::= {SPACE}* {NEWLINE}
\& LEX_ENTRY   ::= {TOKEN_TEXT} {TAB} {TOKEN_TOTAL} ( {TAB} {TAG_COUNT} )*
\& TAG_COUNT   ::= {TAG_TEXT} {TAB} {TOK_TAG_CT}
\& TOKEN_TOTAL ::= {COUNT}
\& TOK_TAG_CT  ::= {COUNT}
\& TOKEN_TEXT  ::= {STRING} | {SPECIAL_TOK}
\& TAG_TEXT    ::= {STRING}
\& STRING      ::= ( [^{TAB}{NEWLINE}] )+
\& COUNT       ::=  ("\-"|"+")? ([0\-9]* ".")? [0\-9]+
\& NEWLINE     ::= "\en" | "\er"
\& TAB         ::= "\et"
\& SPECIAL_TOK ::= "@UNKNOWN"
\&                 | "@CARD"
\&                 | "@CARDSEPS"
\&                 | "@CARDPUNCT"
\&                 | "@CARDSUFFIX"
.Ve
.Sp
Leading and trailing spaces are stripped from token
and tag text.
.Sp
The special tokens whose text begins with an '@' character
declare counts for special token types:
.RS 4
.ie n .IP "* @UNKNOWN" 4
.el .IP "* \f(CW@UNKNOWN\fR" 4
.IX Item "@UNKNOWN"
Declares frequency counts to be used when no other training
data is available (i.e. for alphabetic tokens which did not occur in the
training corpus).
.ie n .IP "* @CARD" 4
.el .IP "* \f(CW@CARD\fR" 4
.IX Item "@CARD"
Declares frequency counts to be used for tokens consisting
only of digits \*(-- tokens which match the regex:
.Sp
.Vb 1
\& [0\-9]+
.Ve
.ie n .IP "* @CARDSEPS" 4
.el .IP "* \f(CW@CARDSEPS\fR" 4
.IX Item "@CARDSEPS"
Declares frequency counts to be used for tokens which
contain digits and separators.  The regex matching
such tokens is (?):
.Sp
.Vb 1
\& ([[:digit:]]+)([\e.\e,\e\-]|[[:digit:]])*
.Ve
.ie n .IP "* @CARDPUNCT" 4
.el .IP "* \f(CW@CARDPUNCT\fR" 4
.IX Item "@CARDPUNCT"
Declares frequency counts to be used for tokens which
contain digits followed by punctuation.
The regex matching such tokens is (?):
.Sp
.Vb 1
\& ([[:digit:]]+)([[:punct:]])
.Ve
.ie n .IP "* @CARDSUFFIX" 4
.el .IP "* \f(CW@CARDSUFFIX\fR" 4
.IX Item "@CARDSUFFIX"
Declares frequency counts to be used for tokens which
contain digits followed by some suffix.
The regex matching
these tokens depends on whether the \f(CW\*(C`moot_TNT_COMPAT\*(C'\fR macro
macro was defined when you compiled libmoot:
.Sp
If \f(CW\*(C`moot_TNT_COMPAT\*(C'\fR was defined, then the suffix
of \*(L"@CARDSUFFIX\*(R" tokens is required to be of maximum
length 3, thus matching the regex:
.Sp
.Vb 1
\& ([[:digit:]]+)(.{1,3})
.Ve
.Sp
Otherwise, the suffix for \*(L"@CARDSUFFIX\*(R" tokens may
be of arbitrary length:
.Sp
.Vb 1
\& ([[:digit:]]+)(.*)
.Ve
.RE
.RS 4
.Sp
An example lexical frequency file is:
.Sp
.Vb 7
\& %% Example lexical frequency file
\& This   4       PDAT    4
\& is     1.0     VVFIN   0.7     VAFIN   0.3
\& a      365     ART     350     CARD    5
\& test   1       NN      0.5     VVFIN   0.5
\& too    1       ADV     1
\& .      42      $.      42
.Ve
.RE
.IP "\fBNgram Frequency Files\fR" 4
.IX Item "Ngram Frequency Files"
An n\-gram frequency file stores raw frequency counts for
uni\-, bi\-, and tri\-grams.  An n\-gram file may be in either
\&\*(L"long\*(R" or \*(L"short\*(R" format, both of which are compatible
with the respective formats produced by the \fItnt\-para\fR\|(1)
program:
.Sp
.Vb 12
\& NGRAM_FILE  ::= ({COMMENT} | {BLANK_LINE} | {NGRAM_ENTRY})*
\& COMMENT     ::= {SPACE}* "%%" ([^{NEWLINE}])*  {NEWLINE}
\& BLANK_LINE  ::= {SPACE}* {NEWLINE}
\& NGRAM_ENTRY ::= {UNIGRAM} | {BIGRAM} | {TRIGRAM}
\& UNIGRAM     ::= {TAG} {TAB} {COUNT}
\& BIGRAM      ::= {TAG} {TAB} {TAG} {TAB} {COUNT}
\& TRIGRAM     ::= {TAG} {TAB} {TAG} {TAB} {TAG} {TAB} {COUNT}
\& TAG         ::= EOS_TAG | ( [^{TAB}{NEWLINE}] )*
\& EOS_TAG     ::= "__$"
\& COUNT       ::=  ("\-"|"+")? ([0\-9]* ".")? [0\-9]+
\& NEWLINE     ::= "\en" | "\er"
\& TAB         ::= "\et"
.Ve
.Sp
Leading and trailing spaces are stripped from tags.
An empty \fI\s-1TAG\s0\fR component is populated with the tag
in the corresponding position from the last n\-gram
parsed \*(-- exhaustive use of this feature produces
\&\*(L"short\*(R" format n\-gram files.  Non-use of this feature
produces \*(L"long\*(R" format n\-gram files.
.Sp
An example \*(L"long\*(R" format n\-gram file is:
.Sp
.Vb 22
\& %% Example n\-gram frequency file in "long" format
\& __$    2
\& __$    PDAT    2
\& __$    PDAT    VVFIN   1
\& __$    PDAT    ADV     1
\& ADV    1
\& ADV    $.      1
\& ADV    $.      __$     1
\& ART    1
\& ART    NN      1
\& ART    NN      $.      1
\& PDAT   2
\& PDAT   VVFIN   1
\& PDAT   VVFIN   ART     1
\& PDAT   ADV     1
\& PDAT   ADV     $.      1
\& VVFIN  1
\& VVFIN  ART     1
\& VVFIN  ART     NN      1
\& NN     1
\& NN     $.      1
\& NN     $.      __$     1
.Ve
.Sp
The same data in \*(L"short\*(R" format:
.Sp
.Vb 22
\& %% Example n\-gram frequency file in "short" format
\& __$    2
\&        PDAT    2
\&                VVFIN   1
\&                ADV     1
\& ADV    1
\&        $.      1
\&                __$     1
\& ART    1
\&                1
\&                $.      1
\& PDAT   2
\&        VVFIN   1
\&                ART     1
\&        ADV     1
\&                $.      1
\& VVFIN  1
\&        ART     1
\&                NN      1
\& NN     1
\&        $.      1
\&                __$     1
.Ve
.IP "\fBLexical-Class Frequency Files\fR" 4
.IX Item "Lexical-Class Frequency Files"
Lexical-class frequency files store raw frequencies for known
lexical classes (read \*(L"sets of possible part-of-speech tags\*(R")
and (class,tag) pairs.  The format is a direct extension
of the format for lexical frequency files
(see \*(L"Lexical Frequency Files\*(R", above):
.Sp
.Vb 4
\& CLASS_FILE  ::= ({COMMENT} | {BLANK_LINE} | {CLASS_ENTRY})*
\& CLASS_ENTRY ::= {CLASS_ELTS} {TAB} {CLASS_TOTAL} ( {TAB} {TAG_COUNT} )*
\& CLASS_ELTS  ::= ( {CLASS_TAG} {SPACE} )*
\& CLASS_TAG   ::= ( [^{SPACE}{TAB}{NEWLINE}] )+
.Ve
.Sp
As for lexical frequency files, leading and trailing whitespaces
are stripped from class and tag text.
.Sp
The \fI\s-1CLASS_ELTS\s0\fR component specifies a (space\-separated) list
of tags belonging to the lexical class.  All other (tab\-separated)
fields are as for a lexical frequency file.
.Sp
A pair (\s-1CLASS\s0,TAG) such that \s-1TAG\s0 is not an element of \s-1CLASS\s0
is called an \*(L"contradictory pair\*(R" or an \*(L"impossible pair\*(R".
It is not required that the the tags in the \fI\s-1TAG_COUNT\s0\fR
components of a \fI\s-1CLASS_ENTRY\s0\fR are \*(L"possible\*(R" in this sense,
although it certainly helps if this is the case.
.Sp
An example lexical class frequency file is:
.Sp
.Vb 7
\& %% Example lexical frequency file
\& PDAT NE        4       PDAT    4
\& VVFIN VAFIN    1.0     VVFIN   0.7     VAFIN   0.3
\& ART CARD       365     ART     350     CARD    5
\& NN VVFIN       1       NN      0.5     VVFIN   0.5
\& ADV            1       ADV     1
\& $.             42      $.      42
.Ve
.Sh "\s-1HMM\s0 Binary Model Files"
.IX Subsection "HMM Binary Model Files"
A \*(L"Binary Model\*(R" \fI\s-1BINMODEL\s0\fR is a (compressed) binary format
file storing a compiled Hidden Markov Model (probabilities
and constants).  It is completely
specified by its filename \fI\s-1BINMODEL\s0\fR.
By convention, \s-1HMM\s0 binary model files carry the suffix
\&\*(L".hmm\*(R".
.PP
When specifying an \s-1HMM\s0 model file,
note that the existence of a file \fI\s-1BINMODEL\s0\fR overrides
any text models which might exists in files
\&\fI\s-1BINMODEL\s0\fR.lex , \fI\s-1BINMODEL\s0\fR.123 , \fI\s-1BINMODEL\s0\fR.clx.
Use of a conventional suffix (such as \*(L".hmm\*(R") to identify binary models
eliminates such problems, since \fI\s-1MODEL\s0\fR.hmm will \fBnot\fR clash
with a text model \fI\s-1MODEL\s0\fR.lex, ...
.Sh "\s-1HMM\s0 Dumps"
.IX Subsection "HMM Dumps"
An \s-1HMM\s0 dump is a plain text file containing all the
information stored in a compiled \s-1HMM\s0.  The format exists
solely for purposes of debugging.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Development of this package was supported by the project
\&'Kollokationen im Wo\*:rterbuch'
( \*(L"collocations in the dictionary\*(R", http://www.bbaw.de/forschung/kollokationen )
in association with the project
\&'Digitales Wo\*:rterbuch der deutschen Sprache des 20. Jahrhunderts (\s-1DWDS\s0)'
( \*(L"digital dictionary of the German language of the 20th century\*(R", http://www.dwds.de )
at the Berlin-Brandenburgische Akademie der Wissenschaften ( http://www.bbaw.de )
with funding from
the Alexander von Humboldt Stiftung ( http://www.avh.de )
and from the Zukunftsinvestitionsprogramm of the
German federal government.
.PP
I am grateful to Christiane Fellbaum, Alexander Geyken,
Gerald Neumann, Edmund Pohl, Alexey Sokirko, and others
for offering useful insights in the course of development
of this package.
.PP
Thomas Hanneforth wrote and maintains the libFSM \*(C+ library
for finite-state device operations used in the
development of the class-based \s-1HMM\s0 tagger / disambiguator.
Alexander Geyken and Thomas Hanneforth developed the
rule-based morphological analysis system for German
which was used in the development of the
class-based \s-1HMM\s0 tagger / disambiguator.
.SH "AUTHOR"
.IX Header "AUTHOR"
Bryan Jurish <moocow@ling.uni\-potsdam.de>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
mootutils
