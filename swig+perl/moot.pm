# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.7
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package moot;
use base qw(Exporter);
use base qw(DynaLoader);
package mootc;
bootstrap moot;
package moot;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package moot;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package moot;

*TokenTypeName = *mootc::TokenTypeName;
*TokenFlavorName = *mootc::TokenFlavorName;
*tokenFlavor = *mootc::tokenFlavor;

############# Class : moot::TokenAnalysis ##############

package moot::TokenAnalysis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_tag_get = *mootc::TokenAnalysis_tag_get;
*swig_tag_set = *mootc::TokenAnalysis_tag_set;
*swig_details_get = *mootc::TokenAnalysis_details_get;
*swig_details_set = *mootc::TokenAnalysis_details_set;
*swig_prob_get = *mootc::TokenAnalysis_prob_get;
*swig_prob_set = *mootc::TokenAnalysis_prob_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_TokenAnalysis(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_TokenAnalysis($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::TokenAnalysis_clear;
*empty = *mootc::TokenAnalysis_empty;
*equal = *mootc::TokenAnalysis_equal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::TokenAnalyses ##############

package moot::TokenAnalyses;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_TokenAnalyses(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_TokenAnalyses($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::TokenAnalyses_clear;
*size = *mootc::TokenAnalyses_size;
*empty = *mootc::TokenAnalyses_empty;
*front = *mootc::TokenAnalyses_front;
*back = *mootc::TokenAnalyses_back;
*rotate = *mootc::TokenAnalyses_rotate;
*push_front = *mootc::TokenAnalyses_push_front;
*push_back = *mootc::TokenAnalyses_push_back;
*pop_front = *mootc::TokenAnalyses_pop_front;
*pop_back = *mootc::TokenAnalyses_pop_back;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::TokenLocation ##############

package moot::TokenLocation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_offset_get = *mootc::TokenLocation_offset_get;
*swig_offset_set = *mootc::TokenLocation_offset_set;
*swig_length_get = *mootc::TokenLocation_length_get;
*swig_length_set = *mootc::TokenLocation_length_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_TokenLocation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_TokenLocation($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::TokenLocation_clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::Token ##############

package moot::Token;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *mootc::Token_type_get;
*swig_type_set = *mootc::Token_type_set;
*swig_text_get = *mootc::Token_text_get;
*swig_text_set = *mootc::Token_text_set;
*swig_tag_get = *mootc::Token_tag_get;
*swig_tag_set = *mootc::Token_tag_set;
*swig_analyses_get = *mootc::Token_analyses_get;
*swig_analyses_set = *mootc::Token_analyses_set;
*swig_location_get = *mootc::Token_location_get;
*swig_location_set = *mootc::Token_location_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_Token(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_Token($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::Token_clear;
*insert = *mootc::Token_insert;
*erase = *mootc::Token_erase;
*flavor = *mootc::Token_flavor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::Sentence ##############

package moot::Sentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_Sentence(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_Sentence($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::Sentence_clear;
*size = *mootc::Sentence_size;
*empty = *mootc::Sentence_empty;
*front = *mootc::Sentence_front;
*back = *mootc::Sentence_back;
*rotate = *mootc::Sentence_rotate;
*push_front = *mootc::Sentence_push_front;
*push_back = *mootc::Sentence_push_back;
*pop_front = *mootc::Sentence_pop_front;
*pop_back = *mootc::Sentence_pop_back;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::StringEnum ##############

package moot::StringEnum;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_StringEnum(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_StringEnum($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::StringEnum_clear;
*nameExists = *mootc::StringEnum_nameExists;
*idExists = *mootc::StringEnum_idExists;
*size = *mootc::StringEnum_size;
*name2id = *mootc::StringEnum_name2id;
*id2name = *mootc::StringEnum_id2name;
*insert = *mootc::StringEnum_insert;
*unknown_name = *mootc::StringEnum_unknown_name;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::IdProbAssocVectorNode ##############

package moot::IdProbAssocVectorNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_first_get = *mootc::IdProbAssocVectorNode_first_get;
*swig_first_set = *mootc::IdProbAssocVectorNode_first_set;
*swig_second_get = *mootc::IdProbAssocVectorNode_second_get;
*swig_second_set = *mootc::IdProbAssocVectorNode_second_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_IdProbAssocVectorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_IdProbAssocVectorNode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::IdProbAssocVector ##############

package moot::IdProbAssocVector;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_IdProbAssocVector(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_IdProbAssocVector($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::IdProbAssocVector_clear;
*size = *mootc::IdProbAssocVector_size;
*find_index = *mootc::IdProbAssocVector_find_index;
*nth = *mootc::IdProbAssocVector_nth;
*get_node = *mootc::IdProbAssocVector_get_node;
*insert = *mootc::IdProbAssocVector_insert;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::HMMLexProbTable ##############

package moot::HMMLexProbTable;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_HMMLexProbTable(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_HMMLexProbTable($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::HMMLexProbTable_clear;
*reserve = *mootc::HMMLexProbTable_reserve;
*resize = *mootc::HMMLexProbTable_resize;
*size = *mootc::HMMLexProbTable_size;
*empty = *mootc::HMMLexProbTable_empty;
*front = *mootc::HMMLexProbTable_front;
*back = *mootc::HMMLexProbTable_back;
*nth = *mootc::HMMLexProbTable_nth;
*push = *mootc::HMMLexProbTable_push;
*pop_back = *mootc::HMMLexProbTable_pop_back;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::Trigram ##############

package moot::Trigram;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_tag1_get = *mootc::Trigram_tag1_get;
*swig_tag1_set = *mootc::Trigram_tag1_set;
*swig_tag2_get = *mootc::Trigram_tag2_get;
*swig_tag2_set = *mootc::Trigram_tag2_set;
*swig_tag3_get = *mootc::Trigram_tag3_get;
*swig_tag3_set = *mootc::Trigram_tag3_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_Trigram(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_Trigram($self);
        delete $OWNER{$self};
    }
}

*hash = *mootc::Trigram_hash;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::HMMNgramProbHash ##############

package moot::HMMNgramProbHash;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_HMMNgramProbHash(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_HMMNgramProbHash($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::HMMNgramProbHash_clear;
*size = *mootc::HMMNgramProbHash_size;
*bucket_count = *mootc::HMMNgramProbHash_bucket_count;
*empty = *mootc::HMMNgramProbHash_empty;
*resize = *mootc::HMMNgramProbHash_resize;
*erase = *mootc::HMMNgramProbHash_erase;
*keyExists = *mootc::HMMNgramProbHash_keyExists;
*get = *mootc::HMMNgramProbHash_get;
*getval = *mootc::HMMNgramProbHash_getval;
*set = *mootc::HMMNgramProbHash_set;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::HMM ##############

package moot::HMM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_verbose_get = *mootc::HMM_verbose_get;
*swig_verbose_set = *mootc::HMM_verbose_set;
*swig_ndots_get = *mootc::HMM_ndots_get;
*swig_ndots_set = *mootc::HMM_ndots_set;
*swig_save_ambiguities_get = *mootc::HMM_save_ambiguities_get;
*swig_save_ambiguities_set = *mootc::HMM_save_ambiguities_set;
*swig_save_flavors_get = *mootc::HMM_save_flavors_get;
*swig_save_flavors_set = *mootc::HMM_save_flavors_set;
*swig_save_mark_unknown_get = *mootc::HMM_save_mark_unknown_get;
*swig_save_mark_unknown_set = *mootc::HMM_save_mark_unknown_set;
*swig_hash_ngrams_get = *mootc::HMM_hash_ngrams_get;
*swig_hash_ngrams_set = *mootc::HMM_hash_ngrams_set;
*swig_relax_get = *mootc::HMM_relax_get;
*swig_relax_set = *mootc::HMM_relax_set;
*swig_use_lex_classes_get = *mootc::HMM_use_lex_classes_get;
*swig_use_lex_classes_set = *mootc::HMM_use_lex_classes_set;
*swig_start_tagid_get = *mootc::HMM_start_tagid_get;
*swig_start_tagid_set = *mootc::HMM_start_tagid_set;
*swig_unknown_lex_threshhold_get = *mootc::HMM_unknown_lex_threshhold_get;
*swig_unknown_lex_threshhold_set = *mootc::HMM_unknown_lex_threshhold_set;
*swig_unknown_class_threshhold_get = *mootc::HMM_unknown_class_threshhold_get;
*swig_unknown_class_threshhold_set = *mootc::HMM_unknown_class_threshhold_set;
*swig_nglambda1_get = *mootc::HMM_nglambda1_get;
*swig_nglambda1_set = *mootc::HMM_nglambda1_set;
*swig_nglambda2_get = *mootc::HMM_nglambda2_get;
*swig_nglambda2_set = *mootc::HMM_nglambda2_set;
*swig_nglambda3_get = *mootc::HMM_nglambda3_get;
*swig_nglambda3_set = *mootc::HMM_nglambda3_set;
*swig_wlambda0_get = *mootc::HMM_wlambda0_get;
*swig_wlambda0_set = *mootc::HMM_wlambda0_set;
*swig_wlambda1_get = *mootc::HMM_wlambda1_get;
*swig_wlambda1_set = *mootc::HMM_wlambda1_set;
*swig_clambda0_get = *mootc::HMM_clambda0_get;
*swig_clambda0_set = *mootc::HMM_clambda0_set;
*swig_clambda1_get = *mootc::HMM_clambda1_get;
*swig_clambda1_set = *mootc::HMM_clambda1_set;
*swig_beamwd_get = *mootc::HMM_beamwd_get;
*swig_beamwd_set = *mootc::HMM_beamwd_set;
*swig_tokids_get = *mootc::HMM_tokids_get;
*swig_tokids_set = *mootc::HMM_tokids_set;
*swig_tagids_get = *mootc::HMM_tagids_get;
*swig_tagids_set = *mootc::HMM_tagids_set;
*flavid = *mootc::HMM_flavid;
*swig_n_tags_get = *mootc::HMM_n_tags_get;
*swig_n_tags_set = *mootc::HMM_n_tags_set;
*swig_n_toks_get = *mootc::HMM_n_toks_get;
*swig_n_toks_set = *mootc::HMM_n_toks_set;
*swig_n_classes_get = *mootc::HMM_n_classes_get;
*swig_n_classes_set = *mootc::HMM_n_classes_set;
*swig_lexprobs_get = *mootc::HMM_lexprobs_get;
*swig_lexprobs_set = *mootc::HMM_lexprobs_set;
*swig_ngprobsh_get = *mootc::HMM_ngprobsh_get;
*swig_ngprobsh_set = *mootc::HMM_ngprobsh_set;
*swig_nsents_get = *mootc::HMM_nsents_get;
*swig_nsents_set = *mootc::HMM_nsents_set;
*swig_ntokens_get = *mootc::HMM_ntokens_get;
*swig_ntokens_set = *mootc::HMM_ntokens_set;
*swig_nnewtokens_get = *mootc::HMM_nnewtokens_get;
*swig_nnewtokens_set = *mootc::HMM_nnewtokens_set;
*swig_nunclassed_get = *mootc::HMM_nunclassed_get;
*swig_nunclassed_set = *mootc::HMM_nunclassed_set;
*swig_nnewclasses_get = *mootc::HMM_nnewclasses_get;
*swig_nnewclasses_set = *mootc::HMM_nnewclasses_set;
*swig_nunknown_get = *mootc::HMM_nunknown_get;
*swig_nunknown_set = *mootc::HMM_nunknown_set;
*swig_nfallbacks_get = *mootc::HMM_nfallbacks_get;
*swig_nfallbacks_set = *mootc::HMM_nfallbacks_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_HMM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_HMM($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::HMM_clear;
*save = *mootc::HMM_save;
*load = *mootc::HMM_load;
*load_model = *mootc::HMM_load_model;
*set_ngram_prob = *mootc::HMM_set_ngram_prob;
*tag_io = *mootc::HMM_tag_io;
*tag_sentence = *mootc::HMM_tag_sentence;
*tag_dump_trace = *mootc::HMM_tag_dump_trace;
*token2id = *mootc::HMM_token2id;
*wordp = *mootc::HMM_wordp;
*tagp = *mootc::HMM_tagp;
*carp = *mootc::HMM_carp;
*txtdump = *mootc::HMM_txtdump;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::DynHMM ##############

package moot::DynHMM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot::HMM moot );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = mootc::new_DynHMM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_DynHMM($self);
        delete $OWNER{$self};
    }
}

*tag_hook_pre = *mootc::DynHMM_tag_hook_pre;
*tag_hook_post = *mootc::DynHMM_tag_hook_post;
*tag_io = *mootc::DynHMM_tag_io;
*tag_sentence = *mootc::DynHMM_tag_sentence;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::DynLexHMM ##############

package moot::DynLexHMM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot::DynHMM moot );
%OWNER = ();
%ITERATORS = ();
*swig_invert_lexp_get = *mootc::DynLexHMM_invert_lexp_get;
*swig_invert_lexp_set = *mootc::DynLexHMM_invert_lexp_set;
*swig_newtag_str_get = *mootc::DynLexHMM_newtag_str_get;
*swig_newtag_str_set = *mootc::DynLexHMM_newtag_str_set;
*swig_newtag_id_get = *mootc::DynLexHMM_newtag_id_get;
*swig_newtag_id_set = *mootc::DynLexHMM_newtag_id_set;
*swig_newtag_f_get = *mootc::DynLexHMM_newtag_f_get;
*swig_newtag_f_set = *mootc::DynLexHMM_newtag_f_set;
*swig_Ftw_eps_get = *mootc::DynLexHMM_Ftw_eps_get;
*swig_Ftw_eps_set = *mootc::DynLexHMM_Ftw_eps_set;
*swig_tagids_size_orig_get = *mootc::DynLexHMM_tagids_size_orig_get;
*swig_tagids_size_orig_set = *mootc::DynLexHMM_tagids_size_orig_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_DynLexHMM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_DynLexHMM($self);
        delete $OWNER{$self};
    }
}

*load_model = *mootc::DynLexHMM_load_model;
*tag_hook_pre = *mootc::DynLexHMM_tag_hook_pre;
*tag_hook_post = *mootc::DynLexHMM_tag_hook_post;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::DynLexHMM_Boltzmann ##############

package moot::DynLexHMM_Boltzmann;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot::DynLexHMM moot );
%OWNER = ();
%ITERATORS = ();
*swig_dynlex_base_get = *mootc::DynLexHMM_Boltzmann_dynlex_base_get;
*swig_dynlex_base_set = *mootc::DynLexHMM_Boltzmann_dynlex_base_set;
*swig_dynlex_beta_get = *mootc::DynLexHMM_Boltzmann_dynlex_beta_get;
*swig_dynlex_beta_set = *mootc::DynLexHMM_Boltzmann_dynlex_beta_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_DynLexHMM_Boltzmann(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_DynLexHMM_Boltzmann($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::Ngrams ##############

package moot::Ngrams;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_ugtotal_get = *mootc::Ngrams_ugtotal_get;
*swig_ugtotal_set = *mootc::Ngrams_ugtotal_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_Ngrams(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_Ngrams($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::Ngrams_clear;
*n_unigrams = *mootc::Ngrams_n_unigrams;
*n_bigrams = *mootc::Ngrams_n_bigrams;
*n_trigrams = *mootc::Ngrams_n_trigrams;
*add_count = *mootc::Ngrams_add_count;
*add_counts = *mootc::Ngrams_add_counts;
*lookup = *mootc::Ngrams_lookup;
*load = *mootc::Ngrams_load;
*save = *mootc::Ngrams_save;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : moot::Lexfreqs ##############

package moot::Lexfreqs;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( moot );
%OWNER = ();
%ITERATORS = ();
*swig_n_tokens_get = *mootc::Lexfreqs_n_tokens_get;
*swig_n_tokens_set = *mootc::Lexfreqs_n_tokens_set;
sub new {
    my $pkg = shift;
    my $self = mootc::new_Lexfreqs(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        mootc::delete_Lexfreqs($self);
        delete $OWNER{$self};
    }
}

*clear = *mootc::Lexfreqs_clear;
*compute_specials = *mootc::Lexfreqs_compute_specials;
*n_pairs = *mootc::Lexfreqs_n_pairs;
*add_count = *mootc::Lexfreqs_add_count;
*taglookup = *mootc::Lexfreqs_taglookup;
*tlookup = *mootc::Lexfreqs_tlookup;
*wlookup = *mootc::Lexfreqs_wlookup;
*wtlookup = *mootc::Lexfreqs_wtlookup;
*load = *mootc::Lexfreqs_load;
*save = *mootc::Lexfreqs_save;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package moot;

*PACKAGE_VERSION = *mootc::PACKAGE_VERSION;
*VERSION = *mootc::VERSION;
*mootProbEpsilon = *mootc::mootProbEpsilon;
*MOOT_PROB_NEG = *mootc::MOOT_PROB_NEG;
*MOOT_PROB_ZERO = *mootc::MOOT_PROB_ZERO;
*MOOT_PROB_ONE = *mootc::MOOT_PROB_ONE;
*MOOT_PROB_NONE = *mootc::MOOT_PROB_NONE;
*TokTypeUnknown = *mootc::TokTypeUnknown;
*TokTypeVanilla = *mootc::TokTypeVanilla;
*TokTypeLibXML = *mootc::TokTypeLibXML;
*TokTypeXMLRaw = *mootc::TokTypeXMLRaw;
*TokTypeComment = *mootc::TokTypeComment;
*TokTypeEOS = *mootc::TokTypeEOS;
*TokTypeEOF = *mootc::TokTypeEOF;
*TokTypeUser = *mootc::TokTypeUser;
*NTokTypes = *mootc::NTokTypes;
*TokFlavorAlpha = *mootc::TokFlavorAlpha;
*TokFlavorCard = *mootc::TokFlavorCard;
*TokFlavorCardPunct = *mootc::TokFlavorCardPunct;
*TokFlavorCardSuffix = *mootc::TokFlavorCardSuffix;
*TokFlavorCardSeps = *mootc::TokFlavorCardSeps;
*TokFlavorUnknown = *mootc::TokFlavorUnknown;
*NTokFlavors = *mootc::NTokFlavors;
*mootEnumNone = *mootc::mootEnumNone;
*HMMvlSilent = *mootc::HMMvlSilent;
*HMMvlErrors = *mootc::HMMvlErrors;
*HMMvlWarnings = *mootc::HMMvlWarnings;
*HMMvlProgress = *mootc::HMMvlProgress;
*HMMvlEverything = *mootc::HMMvlEverything;

sub library_version { return $moot::PACKAGE_VERSION; }
1;
