#ifndef FLEX_HEADER_mootClassfreqsLexer_h
#define FLEX_HEADER_mootClassfreqsLexer_h
#define YY_mootClassfreqsLexer_CHAR unsigned char
#line 1 "/usr/local/share/flex++bison++/flexskel.h"
/* A lexical scanner header generated by flex */
/* MODIFIED FOR C++ CLASS BY Alain Coetmeur: coetmeur(at)icdc.fr */
/* Note that (at) mean the 'at' symbol that I cannot write */
/* because it is expanded to the class name */
/* made at Informatique-CDC, Research&development department */
/* company from the Caisse Des Depots et Consignations */


/*********************************************/
/* SYSTEM dependent declaration, includes... */
/*********************************************/
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
#ifdef __cplusplus
#ifndef YY_USE_PROTOS
#define YY_USE_PROTOS
#endif
#ifndef YY_USE_CLASS
#define YY_USE_CLASS
#endif
#else	/* ! __cplusplus */
#ifdef __STDC__
#ifdef __GNUC__
#else
#endif	/* __GNUC__ */
#ifndef YY_USE_PROTOS
#define YY_USE_PROTOS
#endif
#endif	/* __STDC__ */
#endif	/* ! __cplusplus */
/*********************************************/
/* COMPILER DEPENDENT   MACROS               */
/*********************************************/
/* use prototypes in function declarations */
#ifndef YY_PROTO
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif
#endif
#include <stdio.h>




/* % here is the declaration from section1 %header{  */ 
#line 33 "mootClassfreqsLexer.ll"

#include "mootTypes.h"
#include "mootClassfreqsParser.h"

/*============================================================================
 * Doxygen docs
 *============================================================================*/
/**
\class mootClassfreqsLexer
\brief Flex++ lexer for (TnT-style) moot lexical frequency parameter files. 

\details Supports comments introduced with '%%'.
*/
#line 48 "mootClassfreqsLexer.ll"
#define YY_mootClassfreqsLexer_LEX_PARAM  \
  YY_mootClassfreqsParser_STYPE *yylval, YY_mootClassfreqsParser_LTYPE *yylloc
#line 52 "mootClassfreqsLexer.ll"
#define YY_mootClassfreqsLexer_CLASS  mootClassfreqsLexer
#line 53 "mootClassfreqsLexer.ll"
#define YY_mootClassfreqsLexer_MEMBERS  \
  public: \
    /* -- public typedefs */\
  public: \
   /* -- positional parameters */\
    /** current line*/\
    int theLine;\
    /** current column*/\
    int theColumn;\
    /** token-buffering */\
    moot::mootTagString tokbuf;\
    /** whether to clear the token-buffer on 'tokbuf_append()' */\
    bool tokbuf_clear;\
  private: \
    /* private local data */ \
    bool use_string; \
    char *stringbuf; \
  public: \
    /** virtual destructor to shut up gcc */\
    virtual ~mootClassfreqsLexer(void) {};\
    /** use stream input */\
    void select_streams(FILE *in=stdin, FILE *out=stdout); \
    /** use string input */\
    void select_string(const char *in, FILE *out=stdout); \
    /** for token-buffering: append yyleng characters of yytext to 'tokbuf' */\
    inline void tokbuf_append(char *text, int leng);
#line 80 "mootClassfreqsLexer.ll"
#define YY_mootClassfreqsLexer_CONSTRUCTOR_INIT  :\
  theLine(1), \
  theColumn(1), \
  use_string(false), \
  stringbuf(NULL)
#line 86 "mootClassfreqsLexer.ll"
#define YY_mootClassfreqsLexer_INPUT_CODE  \
  /* yy_input(char *buf, int &result, int max_size) */\
  if (use_string) {\
    size_t len = strlen(stringbuf) > (size_t)max_size ? max_size : strlen(stringbuf);\
    strncpy(buffer,stringbuf,len);\
    stringbuf += len;\
    return result = len;\
  }\
  /* black magic */\
  return result= fread(buffer, 1, max_size, YY_mootClassfreqsLexer_IN);
#line 111 "mootClassfreqsLexer.ll"
#line 52 "/usr/local/share/flex++bison++/flexskel.h"



#ifndef YY_mootClassfreqsLexer_TEXT
#define YY_mootClassfreqsLexer_TEXT yytext
#endif
#ifndef YY_mootClassfreqsLexer_LENG
#define YY_mootClassfreqsLexer_LENG yyleng
#endif
#ifndef YY_mootClassfreqsLexer_IN
#define YY_mootClassfreqsLexer_IN yyin
#endif
#ifndef YY_mootClassfreqsLexer_OUT
#define YY_mootClassfreqsLexer_OUT yyout
#endif
#ifndef YY_mootClassfreqsLexer_LEX_RETURN
#define YY_mootClassfreqsLexer_LEX_RETURN int
#else
#ifndef YY_mootClassfreqsLexer_LEX_DEFINED
#define YY_mootClassfreqsLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_mootClassfreqsLexer_LEX
#define YY_mootClassfreqsLexer_LEX yylex
#else
#ifndef YY_mootClassfreqsLexer_LEX_DEFINED
#define YY_mootClassfreqsLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_mootClassfreqsLexer_LEX_PARAM
#ifndef YY_USE_PROTOS
#define YY_mootClassfreqsLexer_LEX_PARAM 
#else
#define YY_mootClassfreqsLexer_LEX_PARAM void
#endif
#else
#ifndef YY_mootClassfreqsLexer_LEX_DEFINED
#define YY_mootClassfreqsLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_mootClassfreqsLexer_LEX_PARAM_DEF
#define YY_mootClassfreqsLexer_LEX_PARAM_DEF
#else
#ifndef YY_mootClassfreqsLexer_LEX_DEFINED
#define YY_mootClassfreqsLexer_LEX_DEFINED 
#endif
#endif

#ifndef YY_mootClassfreqsLexer_RESTART
#define YY_mootClassfreqsLexer_RESTART yyrestart
#endif
#ifndef YY_mootClassfreqsLexer_SWITCH_TO_BUFFER
#define YY_mootClassfreqsLexer_SWITCH_TO_BUFFER yy_switch_to_buffer
#endif
#ifndef YY_mootClassfreqsLexer_LOAD_BUFFER_STATE
#define YY_mootClassfreqsLexer_LOAD_BUFFER_STATE yy_load_buffer_state
#endif

#ifndef YY_mootClassfreqsLexer_CREATE_BUFFER
#define YY_mootClassfreqsLexer_CREATE_BUFFER yy_create_buffer
#ifndef YY_USE_CLASS
#ifndef yy_new_buffer
#define yy_new_buffer yy_create_buffer
#endif
#endif
#endif
#ifndef YY_mootClassfreqsLexer_DELETE_BUFFER
#define YY_mootClassfreqsLexer_DELETE_BUFFER yy_delete_buffer
#endif
#ifndef YY_mootClassfreqsLexer_INIT_BUFFER
#define YY_mootClassfreqsLexer_INIT_BUFFER yy_init_buffer
#endif
#ifdef YY_mootClassfreqsLexer_FLEX_DEBUG
#ifndef YY_mootClassfreqsLexer_DEBUG
#define YY_mootClassfreqsLexer_DEBUG 1
#endif
#else
#ifndef YY_mootClassfreqsLexer_DEBUG
#define YY_mootClassfreqsLexer_DEBUG 0
#endif
#endif

#if YY_mootClassfreqsLexer_DEBUG != 0
#ifndef YY_mootClassfreqsLexer_DEBUG_FLAG
#define YY_mootClassfreqsLexer_DEBUG_FLAG yy_flex_debug
#endif
#ifndef YY_mootClassfreqsLexer_DEBUG_INIT
#define YY_mootClassfreqsLexer_DEBUG_INIT 1
#endif
#endif




#ifndef YY_USE_CLASS
typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern void YY_mootClassfreqsLexer_RESTART YY_PROTO(( FILE *input_file ));
extern void YY_mootClassfreqsLexer_SWITCH_TO_BUFFER YY_PROTO(( YY_BUFFER_STATE new_buffer ));
extern void YY_mootClassfreqsLexer_LOAD_BUFFER_STATE YY_PROTO(( void ));
extern YY_BUFFER_STATE YY_mootClassfreqsLexer_CREATE_BUFFER YY_PROTO(( FILE *file, int size ));
extern void YY_mootClassfreqsLexer_DELETE_BUFFER YY_PROTO(( YY_BUFFER_STATE b ));
extern void YY_mootClassfreqsLexer_INIT_BUFFER YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));

#if YY_mootClassfreqsLexer_DEBUG != 0
extern int YY_mootClassfreqsLexer_DEBUG_FLAG ;
#endif
extern YY_mootClassfreqsLexer_CHAR  *YY_mootClassfreqsLexer_TEXT;
extern int YY_mootClassfreqsLexer_LENG;
extern FILE *YY_mootClassfreqsLexer_IN, *YY_mootClassfreqsLexer_OUT;
#ifdef YY_mootClassfreqsLexer_LEX_DEFINED
extern YY_mootClassfreqsLexer_LEX_RETURN YY_mootClassfreqsLexer_LEX ( YY_mootClassfreqsLexer_LEX_PARAM )
YY_mootClassfreqsLexer_LEX_PARAM_DEF
#else
#ifndef YY_DECL
extern YY_mootClassfreqsLexer_LEX_RETURN YY_mootClassfreqsLexer_LEX ( YY_mootClassfreqsLexer_LEX_PARAM )
YY_mootClassfreqsLexer_LEX_PARAM_DEF
#else
/* no declaration if oldstyle flex */
#endif
#endif
#else

#ifndef YY_mootClassfreqsLexer_CLASS
#define YY_mootClassfreqsLexer_CLASS mootClassfreqsLexer
#endif
#ifndef YY_mootClassfreqsLexer_ECHO
#define YY_mootClassfreqsLexer_ECHO yy_echo
#endif
#ifdef YY_mootClassfreqsLexer_ECHO_PURE
#define YY_mootClassfreqsLexer_ECHO_NOCODE
#endif
#ifndef YY_mootClassfreqsLexer_ECHO_CODE
#define YY_mootClassfreqsLexer_ECHO_CODE fwrite( (char *) YY_mootClassfreqsLexer_TEXT, YY_mootClassfreqsLexer_LENG, 1, YY_mootClassfreqsLexer_OUT );
#endif
#ifndef YY_mootClassfreqsLexer_INPUT
#define YY_mootClassfreqsLexer_INPUT yy_input
#endif
#ifdef YY_mootClassfreqsLexer_INPUT_PURE
#define YY_mootClassfreqsLexer_INPUT_NOCODE
#endif
#ifndef YY_mootClassfreqsLexer_INPUT_CODE
#define YY_mootClassfreqsLexer_INPUT_CODE return result= fread(  buffer, 1,max_size,YY_mootClassfreqsLexer_IN );
#endif
#ifdef YY_mootClassfreqsLexer_FATAL_ERROR_PURE
#define YY_mootClassfreqsLexer_FATAL_ERRO_NOCODE
#endif
#ifndef YY_mootClassfreqsLexer_FATAL_ERROR
#define YY_mootClassfreqsLexer_FATAL_ERROR yy_fatal_error
#endif
#ifndef YY_mootClassfreqsLexer_FATAL_ERROR_CODE
#define YY_mootClassfreqsLexer_FATAL_ERROR_CODE fputs( msg, stderr );putc( '\n', stderr );exit( 1 );
#endif
#ifndef YY_mootClassfreqsLexer_WRAP
#define YY_mootClassfreqsLexer_WRAP yy_wrap
#endif
#ifdef YY_mootClassfreqsLexer_WRAP_PURE
#define YY_mootClassfreqsLexer_WRAP_NOCODE
#endif
#ifndef YY_mootClassfreqsLexer_WRAP_CODE
#define YY_mootClassfreqsLexer_WRAP_CODE return 1;
#endif


#ifndef YY_mootClassfreqsLexer_INHERIT
#define YY_mootClassfreqsLexer_INHERIT
#endif
#ifndef YY_mootClassfreqsLexer_MEMBERS
#define YY_mootClassfreqsLexer_MEMBERS 
#endif
#ifndef YY_mootClassfreqsLexer_CONSTRUCTOR_PARAM
#define YY_mootClassfreqsLexer_CONSTRUCTOR_PARAM
#endif
#ifndef YY_mootClassfreqsLexer_CONSTRUCTOR_CODE
#define YY_mootClassfreqsLexer_CONSTRUCTOR_CODE
#endif
#ifndef YY_mootClassfreqsLexer_CONSTRUCTOR_INIT
#define YY_mootClassfreqsLexer_CONSTRUCTOR_INIT
#endif
typedef struct yy_buffer_state *YY_BUFFER_STATE;

class YY_mootClassfreqsLexer_CLASS YY_mootClassfreqsLexer_INHERIT
{
 private:/* data */
 YY_mootClassfreqsLexer_CHAR  *yy_c_buf_p;
 YY_mootClassfreqsLexer_CHAR  yy_hold_char;
 int yy_n_chars;
 int yy_init;
 int yy_start;
 int yy_did_buffer_switch_on_eof;
 private: /* functions */
 void yy_initialize();
 int input();
 int yyinput() {return input();};
 int yy_get_next_buffer();
 void yyunput( YY_mootClassfreqsLexer_CHAR  c, YY_mootClassfreqsLexer_CHAR  *buf_ptr );
 /* use long instead of yy_state_type because it is undef */
 long yy_get_previous_state_ ( void );
 long yy_try_NUL_trans_  ( long current_state_ );
 protected:/* non virtual */
 YY_BUFFER_STATE yy_current_buffer;
 void YY_mootClassfreqsLexer_RESTART ( FILE *input_file );
 void YY_mootClassfreqsLexer_SWITCH_TO_BUFFER( YY_BUFFER_STATE new_buffer );
 void YY_mootClassfreqsLexer_LOAD_BUFFER_STATE( void );
 YY_BUFFER_STATE YY_mootClassfreqsLexer_CREATE_BUFFER( FILE *file, int size );
 void YY_mootClassfreqsLexer_DELETE_BUFFER( YY_BUFFER_STATE b );
 void YY_mootClassfreqsLexer_INIT_BUFFER( YY_BUFFER_STATE b, FILE *file );
 protected: /* virtual */
 virtual void YY_mootClassfreqsLexer_ECHO()
#ifdef YY_mootClassfreqsLexer_ECHO_PURE
  =0
#endif
  ;
 virtual int  YY_mootClassfreqsLexer_INPUT(char  *buf,int &result,int max_size)
#ifdef YY_mootClassfreqsLexer_INPUT_PURE
  =0
#endif
  ;
 virtual void  YY_mootClassfreqsLexer_FATAL_ERROR(char *msg)
#ifdef YY_mootClassfreqsLexer_FATAL_ERROR_PURE
  =0
#endif
  ;
 virtual int  YY_mootClassfreqsLexer_WRAP()
#ifdef YY_mootClassfreqsLexer_WRAP_PURE
  =0
#endif
  ;
 public:
 YY_mootClassfreqsLexer_CHAR  *YY_mootClassfreqsLexer_TEXT;
 int YY_mootClassfreqsLexer_LENG;
 FILE *YY_mootClassfreqsLexer_IN, *YY_mootClassfreqsLexer_OUT;
 YY_mootClassfreqsLexer_LEX_RETURN YY_mootClassfreqsLexer_LEX ( YY_mootClassfreqsLexer_LEX_PARAM);
 YY_mootClassfreqsLexer_CLASS(YY_mootClassfreqsLexer_CONSTRUCTOR_PARAM) ;
#if YY_mootClassfreqsLexer_DEBUG != 0
 int YY_mootClassfreqsLexer_DEBUG_FLAG;
#endif
 public: /* added members */
 YY_mootClassfreqsLexer_MEMBERS 
};
#endif



/* declaration of externs for public use of yylex scanner */

/* % here is the declaration from section2 %header{ */ 
#line 161 "mootClassfreqsLexer.ll"
#endif
#line 302 "/usr/local/share/flex++bison++/flexskel.h"

/* end of generated header */
