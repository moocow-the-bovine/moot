<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<link rel="stylesheet" href="mootprogs.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#moot-FILE-FORMATS">moot FILE FORMATS</a></li>
  <li><a href="#PROGRAM-CONFIGURATION-FILES">PROGRAM CONFIGURATION FILES</a></li>
  <li><a href="#TEXT-FILE-FORMATS-NATIVE">TEXT FILE FORMATS (NATIVE)</a>
    <ul>
      <li><a href="#Raw-Text-Files">Raw Text Files</a></li>
      <li><a href="#Cooked-Text-Files">Cooked Text Files</a></li>
    </ul>
  </li>
  <li><a href="#XML-FILE-FORMATS">XML FILE FORMATS</a>
    <ul>
      <li><a href="#Raw-XML-Files">Raw XML Files</a></li>
      <li><a href="#Cooked-XML-Files">Cooked XML Files</a></li>
      <li><a href="#I-O-Format-Flags">I/O Format Flags</a></li>
    </ul>
  </li>
  <li><a href="#HMM-MODEL-FILE-FORMATS">HMM MODEL FILE FORMATS</a>
    <ul>
      <li><a href="#Text-Models">Text Models</a></li>
      <li><a href="#HMM-Binary-Model-Files">HMM Binary Model Files</a></li>
      <li><a href="#HMM-Dumps">HMM Dumps</a></li>
    </ul>
  </li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="moot-FILE-FORMATS">moot FILE FORMATS</h1>

<p>This manpage describes various file formats used by the moot PoS tagging utilities.</p>

<h1 id="PROGRAM-CONFIGURATION-FILES">PROGRAM CONFIGURATION FILES</h1>

<p>Most moot utility programs support global and user-specific configuration files which can be used to set system defaults and/or user preferences for values of program options.</p>

<p>Configuration files are expected to contain lines of the form:</p>

<pre><code> LONG_OPTION_NAME    OPTION_VALUE</code></pre>

<p>where LONG_OPTION_NAME is the long name of one of the program&#39;s options, without the leading &#39;--&#39;, and OPTION_VALUE is the value for that option, if any. Fields are whitespace-separated. Blank lines and comments (lines beginning with a &#39;#&#39; character) are ignored.</p>

<p>The following configuration files are read by default, where ${PROGNAME} is the name of a moot utility program, and ${HOME} is the home directory of the current user:</p>

<dl>

<dt id="etc-PROGNAME-rc">/etc/${PROGNAME}rc</dt>
<dd>

<p>System defaults file; read first.</p>

</dd>
<dt id="HOME-.-PROGNAME-rc">${HOME}/.${PROGNAME}rc</dt>
<dd>

<p>User preferences file, can be used to override system defaults.</p>

</dd>
</dl>

<p>Any options specified on the command-line override defaults from a program configuration file.</p>

<h1 id="TEXT-FILE-FORMATS-NATIVE">TEXT FILE FORMATS (NATIVE)</h1>

<h2 id="Raw-Text-Files">Raw Text Files</h2>

<p>A &quot;raw&quot; text file is just that: any file consiting of (8-bit or variable-width encoded) characters. Such files may be processed by the <a href="./mootpp.html">mootpp</a> preprocessor to produce &quot;rare cooked&quot; (-tagged, -analyzed) text files, or by the <a href="./waste.html">waste</a> tokenizer with an appropriate tokenization model. An example &quot;raw&quot; text file is:</p>

<pre><code> This is a test.  This too.</code></pre>

<p>Raw text files passed to the <a href="./waste.html">waste</a> scanner may additionally contain comments, escapes, and word- and sentence-break hints:</p>

<pre><code> %% COMMENT %%      /* an inline comment string */
 $%$                /* literal percent sign (escape) */
 $WB$               /* word-break hint */
 $SB$               /* sentence-break hint */</code></pre>

<p>An example input file for the <a href="./waste.html">waste</a> scanner is:</p>

<pre><code> This is a %% comment %% text.
 %% comments can contain embedded newlines, %
    provided that they&#39;re escaped by a single &#39;%&#39; sign. %%
 This is an escaped percent sign $%$.
 This is a word-break hint: word-$WB$break.
 This is a sentence-break hint: sentence-$SB$break.</code></pre>

<p>... which should be tokenized as:</p>

<pre><code> This is a text.
 This an escaped percent sign %.
 This is a word-break hint: word-break.
 This is a sentence-break hint: sentence-break.</code></pre>

<p>With token- and sentence boundaries forced at the positions where the respective hints were found in the input.</p>

<h2 id="Cooked-Text-Files">Cooked Text Files</h2>

<p>A &quot;cooked&quot; text file is a text file which encodes information such as token boundaries, sentence boundaries, part-of-speech tag, and/or potential analyses. The moot utilities distinguish between several different types of cooked text file: in order of ascending informational content, these are:</p>

<ul>

<li><p>&quot;rare&quot; (-tagged, -analyzed),</p>

</li>
<li><p>&quot;medium rare&quot; (-tagged, +analyzed),</p>

</li>
<li><p>&quot;medium&quot; (+tagged, -analyzed),</p>

</li>
<li><p>&quot;well done&quot; (+tagged, +analyzed), and</p>

</li>
<li><p>&quot;refried&quot; (+tagged, +analyzed, +evaluated).</p>

</li>
</ul>

<p>Differnent moot utilities require their input files to be more or less &quot;cooked&quot; -- see the documentation of the individual utilities for details.</p>

<p>Native &quot;cooked&quot; text files are conventionally identified by the filename infix &quot;.moot&quot;.</p>

<dl>

<dt id="Rare">Rare</dt>
<dd>

</dd>
<dt id="tagged--analyzed">(-tagged, -analyzed)</dt>
<dd>

</dd>
<dt id="Files:-.t-.r-.rt">Files: *.t, *.r, *.rt</dt>
<dd>

<p>The most basic level of &quot;cookedness&quot;, a &quot;rare&quot; text file encodes only token- and sentence-boundaries. By convention, &quot;rare&quot; filenames carry the extension &quot;.t&quot;. The syntax is:</p>

<pre><code> RARE_FILE  ::= {RARE_LINE}*
 RARE_LINE  ::= ({COMMENT} | {EOS} | {RARE_TOKEN}) {NEWLINE}
 COMMENT    ::= {SPACE}* &quot;%%&quot; ([^{NEWLINE}])*
 EOS        ::= ( {SPACE}* {NEWLINE} )+
 RARE_TOKEN ::= {TOKEN_TEXT}
 TOKEN_TEXT ::= ( {WORDCHAR} | {SPACE} )+
 SPACE      ::= &quot; &quot;
 NEWLINE    ::= &quot;\n&quot; | &quot;\r&quot;
 WORDCHAR   ::= [^{SPACE}{NEWLINE}]</code></pre>

<p>Leading and trailing spaces are stripped from token text; it is thus impossible to declare an &quot;empty&quot; token. An example &quot;rare cooked&quot; file is:</p>

<pre><code> %% Example rare cooked file for moot
 %% Sentence 1
 This
 is
 a
 test
 .
 
 %% Sentence 2
 This
 too
 .</code></pre>

</dd>
<dt id="Medium-Rare">Medium Rare</dt>
<dd>

</dd>
<dt id="tagged-analyzed">(-tagged, +analyzed)</dt>
<dd>

</dd>
<dt id="Files:-.mr-.mrt">Files: *.mr, *.mrt</dt>
<dd>

<p>A &quot;medium rare&quot; file is at least as informative as a &quot;rare&quot; file -- that is, it encodes everything that a &quot;rare&quot; file encodes, and in exactly the same fashion. Additionally, a &quot;medium rare&quot; file may contain for each token a set of (TAB-separated) possible <i>analyses</i> for that token, where an &quot;analysis&quot; contains at least a part-of-speech tag, and possibly also a numeric cost and arbitrary analysis details. Somewhat counter-intuitively, every &quot;rare&quot; file is also a &quot;medium rare&quot; file for which every token is associated with an empty set of possible analyses. By convention, &quot;medium rare&quot; filenames carry the extension &quot;.mrt&quot;</p>

<pre><code> MED_RARE_FILE  ::= {MED_RARE_LINE}*
 MED_RARE_LINE  ::= ({COMMENT} | {EOS} | {MED_RARE_TOKEN}) {NEWLINE}
 MED_RARE_TOKEN ::= {TOKEN_TEXT} ( {TAB} {ANALYSIS} )*
 ANALYSIS       ::= {DETAIL_PREFIX}? {TAG} {DETAIL_SUFFIX}?
 DETAIL_PREFIX  ::= ( {WORDCHAR} | {SPACE} | {COST} )* (&quot;[&quot; (&quot;_&quot;?))?
 COST           ::= &quot;&lt;&quot; (&quot;-&quot;|&quot;+&quot;)? ([0-9]* &quot;.&quot;)? [0-9]+ &quot;&gt;&quot;
 TAG            ::= {TAGCHAR}+
 DETAIL_SUFFIX  ::= ( {WORDCHAR} | {SPACE} | {COST} )*
 TAGCHAR        ::= [^{SPACE}{TAB}{NEWLINE}&quot;]&quot;]
 TAB            ::= &quot;\t&quot;</code></pre>

<p>Leading and trailing spaces are stripped from token text, as well as from analysis-detail and -tag text. It should be noted that the <i>TAG</i> component of each <i>ANALYSIS</i> is &quot;greedy&quot; -- if an analysis contains no left-bracket to mark the beginning of a tag, then the whole analysis (up to the first right-bracket or space) is considered the tag. Also, if the analysis contains multiple left-brackets, only the <i>first</i> is considered to introduce the <i>TAG</i> component. An example &quot;medium rare&quot; file is:</p>

<pre><code> %% Example medium-rare cooked file for moot
 %% Sentence 1 : possible analyses are tags only
 This   NE      PDAT    PDIS
 is     VAFIN   VVFIN
 a      ART     CARD
 test   NN      VVIN
 .      $.
 
 %% Sentence 2 : detailed analyses, with unknown word &quot;foo&quot;.
 This   This [NE type=&quot;name&quot;] &lt;420&gt;      &lt;24.7&gt; this [_PDAT][_sg]
 foo
 .      . [$.] &lt;-42&gt;</code></pre>

<p>Tokens in &quot;medium rare&quot; files with empty analysis sets (i.e. <i>RARE_TOKEN</i>s) are called &quot;unrecognized&quot; tokens.</p>

</dd>
<dt id="Medium">Medium</dt>
<dd>

</dd>
<dt id="tagged--analyzed1">(+tagged, -analyzed)</dt>
<dd>

</dd>
<dt id="Files:-.tt-.ttt-.m-.mt">Files: *.tt, *.ttt, *.m, *.mt</dt>
<dd>

<p>A &quot;medium&quot; file can be understood as a &quot;medium rare&quot; file which associates exactly one analysis with each token. The tag for this analysis is considered the &quot;best&quot; tag for the associated token. By convention, &quot;medium&quot; filenames carry the extension &quot;.tt&quot; (tagger output) or &quot;.ttt&quot; (gold standard).</p>

<pre><code> MEDIUM_FILE    ::= {MEDIUM_LINE}*
 MEDIUM_LINE    ::= ({COMMENT} | {EOS} | {MEDIUM_TOKEN}) {NEWLINE}
 MEDIUM_TOKEN   ::= {TOKEN_TEXT} {TAB} {BEST_ANALYSIS}
 BEST_ANALYSIS  ::= {ANALYSIS}</code></pre>

<p>As before, leading and trailing spaces are stripped from token text and analyses, and the <i>TAG</i> component of each <i>ANALYSIS</i> is &quot;greedy&quot;. An example &quot;medium&quot; file is:</p>

<pre><code> %% Example medium cooked file for moot
 %% Sentence 1 : best analyses are tags only
 This   PDAT
 is     VVFIN
 a      ART
 test   NN
 .      $.
 
 %% Sentence 2 : tags embedded in detailed analyses
 This   &lt;24.7&gt; this [PDAT num=&quot;sg&quot;]
 too    &lt;0.0&gt; too [ADV]
 .      &lt;-42&gt; . [$.]</code></pre>

</dd>
<dt id="Well-Done">Well Done</dt>
<dd>

</dd>
<dt id="tagged-analyzed1">(+tagged, +analyzed)</dt>
<dd>

</dd>
<dt id="Files:-.wd-.wdt">Files: *.wd, *.wdt</dt>
<dd>

<p>A &quot;well done&quot; file can be understood as the synthesis of a &quot;medium rare&quot; and a &quot;medium&quot; file: it contains a &quot;best&quot; analysis for each token (the first one), as well as a set of <i>a priori</i> potential analyses analyses for that token. By convention, &quot;well done&quot; filenames carry the extension &quot;.wd&quot; (tagger output) or &quot;.wdt&quot; (gold standard).</p>

<pre><code> WELL_DONE_FILE  ::= {WELL_DONE_LINE}*
 WELL_DONE_LINE  ::= ({COMMENT} | {EOS} | {WELL_DONE_TOKEN}) {NEWLINE}
 WELL_DONE_TOKEN ::= {TOKEN_TEXT} {TAB} {BEST_ANALYSIS} ( {TAB} {ANALYSIS} )*</code></pre>

<p>As before, leading and trailing spaces are stripped from token text and analyses, and the <i>TAG</i> component of each <i>ANALYSIS</i> is &quot;greedy&quot;. An example &quot;well done&quot; file is:</p>

<pre><code> %% Example well-done cooked file for moot
 %% Sentence 1 : analysis-set tags bracketed for clarity
 This   PDAT    [NE]    [PDAT]    [PDIS]
 is     VVFIN   [VAFIN] [VVFIN]
 a      ART     [ART]   [CARD]
 test   NN      [NN]    [VVFIN]
 .      $.      [$.]
 
 %% Sentence 2 : analysis-tags embedded in complete analyses
 This   PDAT    [NE type=&quot;last&quot;] This &lt;420&gt;  [PDAT num=&quot;sg&quot;] this &lt;24.7&gt;
 too    ADV     [ADV] too &lt;0.0&gt;
 .      $.      [$.] . &lt;-42&gt;</code></pre>

</dd>
<dt id="Refried">Refried</dt>
<dd>

</dd>
<dt id="tagged-analyzed-evaluated">(+tagged, +analyzed, +evaluated)</dt>
<dd>

<p>A &quot;refried&quot; file is basically the synthesis of a pair of &quot;medium&quot; or &quot;well done&quot; files. &quot;Refried&quot; files can be created by the <i>mooteval</i> program from a pair of parallel cooked files. Each line of a &quot;refried&quot; file contains an status code, and a pair of &quot;well-done&quot; style token analyses separated by tabs and a single slash &#39;/&#39;.</p>

<pre><code> REFRIED_FILE     ::= {REFRIED_LINE}*
 REFRIED_LINE     ::= ( {COMMENT} | {EOS} | {REFRIED_TOKEN} ) {NEWLINE}
 REFRIED_TOKEN    ::= {STATUS_CODE} {TAB} {REFRIED_SOURCES}
 REFRIED_SOURCES  ::= {WELL_DONE_TOKEN} {TAB} &quot;/&quot; {TAB} {WELL_DONE_TOKEN}
 STATUS_CODE      ::= {BASIC_FLAGS} &quot;:&quot; {FILE1_FLAGS} &quot;:&quot; {FILE2_FLAGS}
 BASIC_FLAGS      ::= {TOKMATCH_FLAG} {BESTMATCH_FLAG}
 TOKMATCH_FLAG    ::= &quot;-&quot; | &quot;t&quot;
 BESTMATCH_FLAG   ::= &quot;-&quot; | &quot;b&quot;
 FILE1_FLAGS      ::= {FILE_FLAGS}
 FILE2_FLAGS      ::= {FILE_FLAGS}
 FILE_FLAGS       ::= {EMPTY_FLAG} {IMPOSSIBLE_FLAG} {XIMPOSSIBLE_FLAG}
 EMPTY_FLAG       ::= &quot;-&quot; | &quot;e&quot;
 IMPOSSIBLE_FLAG  ::= &quot;-&quot; | &quot;i&quot;
 XIMPOSSIBLE_FLAG ::= &quot;-&quot; | &quot;x&quot;</code></pre>

<p>As before, leading and trailing spaces are stripped from token text and analyses, and the <i>TAG</i> component of each <i>ANALYSIS</i> is &quot;greedy&quot;.</p>

<p>The STATUS_CODE component of each REFRIED_TOKEN encodes a number of flags concerning which part (if any) of the tokens compared did not match. The general convention is use of a &#39;-&#39; character to indicate that the compared tokens matched (or at least were compatible).</p>

<dl>

<dt id="TOKMATCH_FLAG">TOKMATCH_FLAG</dt>
<dd>

<p>&#39;-&#39; if token text components matched, otherwise &#39;t&#39;.</p>

</dd>
<dt id="BESTMATCH_FLAG">BESTMATCH_FLAG</dt>
<dd>

<p>&#39;-&#39; if best-tag components matched, otherwise &#39;b&#39;.</p>

</dd>
<dt id="EMPTY_FLAG">EMPTY_FLAG</dt>
<dd>

<p>&#39;-&#39; if token ANALYSES were non-empty (for the given file), otherwise &#39;e&#39;.</p>

</dd>
<dt id="IMPOSSIBLE_FLAG">IMPOSSIBLE_FLAG</dt>
<dd>

<p>&#39;-&#39; if token ANALYSES included token BESTTAG (for the corresponding file), otherwise &#39;i&#39;.</p>

</dd>
<dt id="XIMPOSSIBLE_FLAG">XIMPOSSIBLE_FLAG</dt>
<dd>

<p>&#39;-&#39; if token ANALYSES included token BESTTAG for the <b>other</b> file, otherwise &#39;x&#39;.</p>

</dd>
</dl>

<p>An example &quot;refried&quot; file is:</p>

<pre><code> %% Example refried file for moot
 %% FLAGS       TOK1    TOK1TAG1 ...            /       TOK2    TOK2TAG1 ...
 %%------------------------------------------------------------------------------------
 t-:---:---     Dis     PDAT    [PDAT]  [PDIS]  /       This    PDAT    [PDAT]  [PDIS]
 -b:---:---     is      VAFIN   [VAFIN] [VVFIN] /       is      VVFIN   [VAFIN] [VVFIN]
 --:e--:---     a       ART     /       a       ART     [ART]   [CARD]
 -b:-i-:---     test    NN      [VVFIN] /       test    VVFIN   [NN]    [VVFIN]
 --:---:---     .       $.      [$.]    /       .       $.      [$.]
 
 -b:--x:---     This    PDAT    [PDAT]  /       This    PDIS    [PDAT]  [PDIS]
 --:---:-ix     too     ADV     [ADV]   [PTKA]  /       too     ADV     [CONJ]
 --:---:e--     .       $.      [$.]    /       .       $.</code></pre>

<p>Re-formatting for better human readabilty produces:</p>

<pre><code> %% Example refried file for moot
 %% FLAGS       TOK1    TOK1TAG1 ...            /       TOK2    TOK2TAG1 ...
 %%------------------------------------------------------------------------------------
 t-:---:---     Dis     PDAT    [PDAT]  [PDIS]  /       This    PDAT    [PDAT]  [PDIS]
 -b:---:---     is      VAFIN   [VAFIN] [VVFIN] /       is      VVFIN   [VAFIN] [VVFIN]
 --:e--:---     a       ART                     /       a       ART     [ART]   [CARD]
 -b:-i-:---     test    NN      [VVFIN]         /       test    VVFIN   [NN]    [VVFIN]
 --:---:---     .       $.      [$.]            /       .       $.      [$.]
 
 -b:--x:---     This    PDAT    [PDAT]          /       This    PDIS    [PDAT]  [PDIS]
 --:---:-ix     too     ADV     [ADV]   [PTKA]  /       too     ADV     [CONJ]
 --:---:e--     .       $.      [$.]            /       .       $.</code></pre>

</dd>
</dl>

<h1 id="XML-FILE-FORMATS">XML FILE FORMATS</h1>

<p>moot currently uses the (extremely cool and amazingly fast) Expat XML parser library by James Clark for incremental processing of XML documents, (a previous implementation used libxml2 (also extremely cool but not quite as amazingly fast as expat), but the moot libxml2 support is no longer maintained, and is disabled by default), as well as output recoding using librecode by Fran&ccedil;ois Pinard. Both expat and librecode support are compile-time options -- check the contents of &#39;mootConfig.h&#39; to see whether they are enabled on your system.</p>

<p>When working with &quot;cooked&quot; XML (see below), it is critical to remember that the moot internal processing routines <b>always</b> receive token and PoS-tag text encoded in UTF-8, <i>regardless</i> of the document encoding. This is of particular importance when converting from native to XML format i.e. with &#39;mootchurn&#39; -- it is highly reccommended that you use the &#39;recode&#39; command-line utility (distributed with &#39;librecode&#39;) to ensure that your native text data is true UTF-8 before passing it to &#39;mootchurn&#39; for XML output.</p>

<p>Similarly, HMM model data (see <a href="#HMM-MODEL-FILE-FORMATS">&quot;HMM MODEL FILE FORMATS&quot;</a>) <b>must</b> be UTF-8 encoded for tagging in XML mode. There is currently no way to directly convert the encoding of a binary model file, but text model files can be converted with the &#39;recode&#39; command-line utility.</p>

<p>Future implementations might use locale information to (partially) automate the recoding process. If all of your data (training corpus, test corpus, and runtime corpora) are parsed in XML mode, none of the above should present a problem.</p>

<p>XML files are identified by the filename infix &#39;.xml&#39;.</p>

<h2 id="Raw-XML-Files">Raw XML Files</h2>

<p>A &quot;raw&quot; XML file is just like a &quot;raw&quot; text file. The &#39;mootpp&#39; program supports rudimentary recognition and removal of (SG|HT|X)ML markup.</p>

<h2 id="Cooked-XML-Files">Cooked XML Files</h2>

<p>As of version 2.0.0, the moot utilities support &quot;cooked&quot; XML files, in addition to the native text format(s). See &quot;Cooked Text Files&quot; above for more details on the native formats and the information content corresponding to the various subtypes.</p>

<p>All &quot;cooked&quot; XML formats share the same structure (much as the &quot;cooked&quot; text formats are defined in terms of one another). The preliminary syntax (subject to change without notice) is:</p>

<pre><code> COOKED_XML_FILE    ::= {XML_DECL}? {XML_CONTENT}*
 XML_DECL           ::= &quot;&lt;?xml &quot; ... &quot;?&gt;&quot;
 XML_CONTENT        ::= {XML_EOS} | {XML_RAW} | {XML_TOKEN}
 XML_EOS            ::= &quot;&lt;eos/&gt;&quot;
 XML_RAW            ::= ...
 XML_TOKEN          ::= &quot;&lt;token&gt;&quot; {XML_TOKEN_CONTENT} &quot;&lt;/token&gt;&quot;
 XML_TOKEN_CONTENT  ::= ({XML_TOKEN_TEXT}
                         | {XML_TOKEN_ANALYSIS}
                         | {XML_TOKEN_BESTTAG}
                         | {XML_RAW})*
 XML_TOKEN_TEXT     ::= &quot;&lt;text&gt;&quot; {TOKEN_TEXT} &quot;&lt;/text&gt;&quot;
 XML_TOKEN_BESTTAG  ::= &quot;&lt;moot.tag&gt;&quot; {TOKEN_BESTTAG} &quot;&lt;/moot.tag&gt;&quot;
 XML_TOKEN_ANALYSIS ::= &#39;&lt;analysis pos=&quot;&#39; {ANALYSIS_TAG} &#39;&quot;&gt;&#39; {ANALYSIS_DETAILS} &quot;&lt;/analysis&gt;&quot;
 ANALYSIS_DETAILS   ::= {XML_RAW}*</code></pre>

<p>The document structure is thus expected to be something like the following (in a bastard notation born of BNF and XPath):</p>

<pre><code> SENTENCE_BOUNDARY  ::= //eos                            # really only end-elts
 TOKEN_TEXT         ::= //token//text/text()             # should be accurate
 ANALYIS_TAG        ::= //token//analysis/@pos           # uses attribute value (not full node)
 ANALYSIS_DETAILS   ::= //token//analysis/text()         # buggy -- actually ignored!
 TOKEN_BESTTAG      ::= //token//moot.tag[last()]/text() # should be accurate</code></pre>

<p>Contact the author if you need any of the following done:</p>

<dl>

<dt id="TODO">TODO</dt>
<dd>

<p>Pull up literal element name parameters from TokenReaderExpat to user-level.</p>

</dd>
<dt id="TODO1">TODO</dt>
<dd>

<p>Add a DTD for the default XML format to the distribution.</p>

</dd>
</dl>

<p>An example &quot;cooked&quot; XML document is the following:</p>

<pre><code> &lt;?xml version=&quot;1.0&quot;?&gt;
 &lt;doc&gt;
  &lt;!-- Sentence-1 : Well Done, Medium, and Medium Rare --&gt;
  &lt;token&gt;
    &lt;!-- A &#39;well done&#39; token with minimal structure --&gt;
    &lt;text&gt;This&lt;/text&gt;
    &lt;moot.tag&gt;PDAT&lt;/moot.tag&gt;
    &lt;analysis pos=&quot;NE&quot;/&gt;
    &lt;analysis pos=&quot;NN&quot;/&gt;
    &lt;analysis pos=&quot;PDAT&quot;/&gt;
    &lt;analysis pos=&quot;PDS&quot;/&gt;
  &lt;/token&gt;
  &lt;token&gt;
    &lt;!-- A &#39;well done&#39; token with extra structure --&gt;
    &lt;text&gt;is&lt;/text&gt;
    &lt;extraneous.element&gt;
      &lt;analysis pos=&quot;VAFIN&quot;/&gt;
      &lt;moot.tag&gt;VVFIN&lt;/moot.tag&gt;
      &lt;analysis pos=&quot;VVFIN&quot;/&gt;
    &lt;/extraneous.element&gt;
  &lt;/token&gt;
  &lt;token&gt;
    &lt;!-- Yet another &#39;well done&#39; token  --&gt;
    &lt;text&gt;a&lt;/text&gt;
    &lt;other_extraneous_element&gt;
      &lt;analysis pos=&quot;ART&quot;/&gt;
    &lt;/other_extraneous_element&gt;
    &lt;moot.tag&gt;ART&lt;/moot.tag&gt;
  &lt;/token&gt;
  &lt;token&gt;
    &lt;!-- A &#39;medium&#39; token --&gt;
    &lt;text&gt;Test&lt;/text&gt;
    &lt;moot.tag&gt;NN&lt;/moot.tag&gt;
  &lt;/token&gt;
  &lt;token&gt;
    &lt;!-- A &#39;Medium Rare&#39; token --&gt;
    &lt;text&gt;.&lt;/text&gt;
    &lt;analysis pos=&quot;$.&quot;/&gt;
  &lt;/token&gt;
  &lt;eos/&gt;
  &lt;!-- Sentence-2 : Rare tokens only --&gt;
  &lt;token&gt;&lt;text&gt;This&lt;/text&gt;&lt;/token&gt;
  &lt;token&gt;&lt;text&gt;too&lt;/text&gt;&lt;/token&gt;
  &lt;token&gt;&lt;text&gt;.&lt;/text&gt;&lt;/token&gt;
  &lt;eos/&gt;
 &lt;/doc&gt;</code></pre>

<h2 id="I-O-Format-Flags">I/O Format Flags</h2>

<p>Several moot utilities are capable of processing input in a number of different formats, typically specified by &#39;--input-format&#39; (-I) and &#39;--output-format&#39; (-O) command-line options The following list briefly describes the (case-insensitive) format flags which may occur as individual elements of the comma-separated list passed as an argument to these format options. Each format flag may be preceeded by an exclamation point &quot;!&quot; to indicate the negation of the respective format property. Note that at the current time, not all formats support all available flags.</p>

<p>If no format flags are specified by the user, the moot utilities will attempt to guess an appropriate format based on the filename and on the requirements for the particular utility in question.</p>

<dl>

<dt id="Basic-Flags">Basic Flags</dt>
<dd>

<dl>

<dt id="None">None</dt>
<dd>

<p>No flags at all. This should never really happen at runtime, and should cause a default format to be assumed and/or an appropriate format to be guessed from the relevant filename(s).</p>

</dd>
<dt id="Null">Null</dt>
<dd>

<p>If you specify &#39;null&#39; as an output format, no output will actually be written (useful for testing and benchmarking the input layer).</p>

</dd>
<dt id="Unknown">Unknown</dt>
<dd>

<p>Unknown format. This should never ever happen, and should cause a reversion to some default format.</p>

</dd>
<dt id="Native">Native</dt>
<dd>

<p>Specifies native text format I/O, as opposed to XML.</p>

</dd>
<dt id="XML">XML</dt>
<dd>

<p>Specifies XML format I/O, as opposed to a native text format.</p>

</dd>
<dt id="Pretty">Pretty</dt>
<dd>

<p>Beautified XML format. Useful for human-readable XML output. Not all XML I/O modes support cosmetic surgery.</p>

</dd>
<dt id="Conserve">Conserve</dt>
<dd>

<p>Conservative XML format: attempt to preserve as much of the input document structure as possible. Only meaningful if both XML input and XML output are requested.</p>

</dd>
<dt id="Text">Text</dt>
<dd>

<p>Read/write token text (all formats).</p>

</dd>
<dt id="Analyzed">Analyzed</dt>
<dd>

<p>Read/write token analyses (&#39;medium rare&#39; or &#39;well done&#39; formats only).</p>

</dd>
<dt id="Tagged">Tagged</dt>
<dd>

<p>Read/write &#39;best tags&#39; (&#39;medium&#39; or &#39;well done&#39; formats only).</p>

</dd>
<dt id="Location">Location</dt>
<dd>

<p>Read/write token locations as logical pairs (BYTE_OFFSET,BYTE_LENGTH) from/to the input stream as the first non-tag analysis. Useful if you need to refer back to earlier stages of a token processing pipeline.</p>

</dd>
<dt id="Cost">Cost</dt>
<dd>

<p>Read/write analysis &quot;costs&quot; from/to analysis &quot;&lt;<i>NUMBER</i>&gt;&quot; suffixes. This flag may be set by default in future versions.</p>

</dd>
<dt id="Pruned">Pruned</dt>
<dd>

<p>For &#39;well done&#39; formats, ignore analyses which do not correspond to the &#39;best&#39; tag.</p>

</dd>
<dt id="Trace">Trace</dt>
<dd>

<p>If set as an output format flag, causes a verbose dump of the Viterbi trellis to be spliced into every tagged sentence as post-token comments. Does nothing as an input flag (yet). Implies &quot;Flush&quot;.</p>

</dd>
<dt id="Predict">Predict</dt>
<dd>

<p>If set as an output flag, cases a verbose dump of Viterbi trellis-based predictions to be spliced into every tagged sentence as post-token comments. Does nothing as an input flag (yet). Implies both &quot;Trace&quot; and &quot;Flush&quot;.</p>

</dd>
<dt id="Flush">Flush</dt>
<dd>

<p>If set as an output flag, causes the underlying output stream to be implicitly flushed after each write operation. Currently only meaningful for native output mode. Does nothing as an input flag (yet).</p>

</dd>
</dl>

</dd>
<dt id="Compound-Flags">Compound Flags</dt>
<dd>

<dl>

<dt id="Rare1">Rare</dt>
<dd>

</dd>
<dt id="R">R</dt>
<dd>

<p>Alias for &#39;Text&#39;.</p>

</dd>
<dt id="MediumRare">MediumRare</dt>
<dd>

</dd>
<dt id="MR">MR</dt>
<dd>

<p>Alias for &#39;Text,Analyzed&#39;.</p>

</dd>
<dt id="Medium1">Medium</dt>
<dd>

</dd>
<dt id="M">M</dt>
<dd>

<p>Alias for &#39;Text,Tagged&#39;.</p>

</dd>
<dt id="WellDone">WellDone</dt>
<dd>

</dd>
<dt id="WD">WD</dt>
<dd>

<p>Alias for &#39;Text,Tagged,Analyzed&#39;</p>

</dd>
</dl>

</dd>
<dt id="Examples">Examples</dt>
<dd>

<ul>

<li><p>Read input as native rare text (tokens only), write output as medium (best-tagged) native text:</p>

<pre><code> moot --input-format=native,text --output-format=native,text,tagged</code></pre>

<p>Same thing, only shorter:</p>

<pre><code> moot --input-format=rare --output-format=medium</code></pre>

<p>Same thing, even shorter:</p>

<pre><code> moot -Ir -Om</code></pre>

<p>Same thing, using filename conventions:</p>

<pre><code> moot input.moot.t -o output.moot.tt</code></pre>

</li>
<li><p>Read medium rare (pre-analyzed) XML, write well-done native text:</p>

<pre><code> moot -I xml,mediumrare -O native,welldone</code></pre>

<p>Same thing, using filename conventions:</p>

<pre><code> moot input.mr.xml -o output.wd.moot</code></pre>

</li>
</ul>

</dd>
</dl>

<h1 id="HMM-MODEL-FILE-FORMATS">HMM MODEL FILE FORMATS</h1>

<p>The moothmm(1) program can use either text- or native binary-format model files, which encode raw frequency counts (text model files), or probability tables and compile-time flags for the Hidden Markov Model (binary model files), respectively.</p>

<h2 id="Text-Models">Text Models</h2>

<p>A &quot;Text Model&quot; is completely specified by up to four files: a lexical freqency file (*.lex), an n-gram frequency file (*.123), an optional lexical-class frequency file (*.clx), and an optional surface/typographical heuristic `flavor&#39; rule file (*.fla).</p>

<p>When specifiying a text model name to a moot utility program, you may specify the model name as <i>TMODEL</i> in order to use the files <i>TMODEL</i>.lex , <i>TMODEL</i>.123 , <i>TMODEL</i>.clx , and <i>TMODEL</i>.fla (if present). Otherwise, you may specifiy a composite model name as a comma-separated list of the individual component filenames: <i>mylex.lex,myngrams.123,myclasses.clx,myclasses.fla</i>. Any positional field in the specification may be left blank to omit loading the associated data; e.g. to omit lexical classes but include flavor definitions, you can specify a model as <i>mylex.lex,myngrams.123,,myclasses.fla</i>.</p>

<dl>

<dt id="Lexical-Frequency-Files"><b>Lexical Frequency Files</b></dt>
<dd>

<p>Lexical frequency files store raw frequencies for known tokens and (token,tag) pairs. The format use is ca. 99.998% compatible with that generated by the tnt-para(1) program:</p>

<pre><code> LEX_FILE    ::= ({COMMENT} | {BLANK_LINE} | {LEX_ENTRY})*
 COMMENT     ::= {SPACE}* &quot;%%&quot; ([^{NEWLINE}])*  {NEWLINE}
 BLANK_LINE  ::= {SPACE}* {NEWLINE}
 LEX_ENTRY   ::= {TOKEN_TEXT} {TAB} {TOKEN_TOTAL} ( {TAB} {TAG_COUNT} )*
 TAG_COUNT   ::= {TAG_TEXT} {TAB} {TOK_TAG_CT}
 TOKEN_TOTAL ::= {COUNT}
 TOK_TAG_CT  ::= {COUNT}
 TOKEN_TEXT  ::= {STRING} | {SPECIAL_TOK}
 TAG_TEXT    ::= {STRING}
 STRING      ::= ( [^{TAB}{NEWLINE}] )+
 COUNT       ::=  (&quot;-&quot;|&quot;+&quot;)? ([0-9]* &quot;.&quot;)? [0-9]+
 NEWLINE     ::= &quot;\n&quot; | &quot;\r&quot;
 TAB         ::= &quot;\t&quot;
 SPECIAL_TOK ::= &quot;@UNKNOWN&quot;
                 | {FLAVOR_LABEL}</code></pre>

<p>Leading and trailing spaces are stripped from token and tag text.</p>

<p>The special tokens whose text conventionally begins with an &#39;@&#39; character declare counts for special pseudo-tokens. In particular, the entry for <b>@UNKNOWN</b> -- if it exists -- declares frequency counts to be used when no other training data is available (i.e. for alphabetic tokens which did not occur in the training corpus).</p>

<p>Other known pseudo-tokens represent training counts to use for unknown tokens which match one of the model&#39;s typographical classification rules. The entries are identified in the lexical frequency file by the flavor&#39;s label (e.g. &quot;@CARD&quot;, &quot;@CARDSEPS&quot;, &quot;@CARDPUNCT&quot;, or &quot;@CARDSUFFIX&quot; for the default built-in flavor rules). See <a href="#Flavor-Definition-Files">&quot;Flavor Definition Files&quot;</a> for details on the typographical classification heuristics supported by moot.</p>

<p>An example lexical frequency file is:</p>

<pre><code> %% Example lexical frequency file
 This   4       PDAT    4
 is     1.0     VVFIN   0.7     VAFIN   0.3
 a      365     ART     350     CARD    5
 test   1       NN      0.5     VVFIN   0.5
 too    1       ADV     1
 .      42      $.      42</code></pre>

</dd>
<dt id="Ngram-Frequency-Files"><b>Ngram Frequency Files</b></dt>
<dd>

<p>An n-gram frequency file stores raw frequency counts for uni-, bi-, and tri-grams. An n-gram file may be in either &quot;long&quot; or &quot;short&quot; format, both of which are compatible with the respective formats produced by the tnt-para(1) program:</p>

<pre><code> NGRAM_FILE  ::= ({COMMENT} | {BLANK_LINE} | {NGRAM_ENTRY})*
 COMMENT     ::= {SPACE}* &quot;%%&quot; ([^{NEWLINE}])*  {NEWLINE}
 BLANK_LINE  ::= {SPACE}* {NEWLINE}
 NGRAM_ENTRY ::= {UNIGRAM} | {BIGRAM} | {TRIGRAM}
 UNIGRAM     ::= {TAG} {TAB} {COUNT}
 BIGRAM      ::= {TAG} {TAB} {TAG} {TAB} {COUNT}
 TRIGRAM     ::= {TAG} {TAB} {TAG} {TAB} {TAG} {TAB} {COUNT}
 TAG         ::= EOS_TAG | ( [^{TAB}{NEWLINE}] )*
 EOS_TAG     ::= &quot;__$&quot;
 COUNT       ::=  (&quot;-&quot;|&quot;+&quot;)? ([0-9]* &quot;.&quot;)? [0-9]+
 NEWLINE     ::= &quot;\n&quot; | &quot;\r&quot;
 TAB         ::= &quot;\t&quot;</code></pre>

<p>Leading and trailing spaces are stripped from tags. An empty <i>TAG</i> component is populated with the tag in the corresponding position from the last n-gram parsed -- exhaustive use of this feature produces &quot;short&quot; format n-gram files. Non-use of this feature produces &quot;long&quot; format n-gram files.</p>

<p>An example &quot;long&quot; format n-gram file is:</p>

<pre><code> %% Example n-gram frequency file in &quot;long&quot; format
 __$    2
 __$    PDAT    2
 __$    PDAT    VVFIN   1
 __$    PDAT    ADV     1
 ADV    1
 ADV    $.      1
 ADV    $.      __$     1
 ART    1
 ART    NN      1
 ART    NN      $.      1
 PDAT   2
 PDAT   VVFIN   1
 PDAT   VVFIN   ART     1
 PDAT   ADV     1
 PDAT   ADV     $.      1
 VVFIN  1
 VVFIN  ART     1
 VVFIN  ART     NN      1
 NN     1
 NN     $.      1
 NN     $.      __$     1</code></pre>

<p>The same data in &quot;short&quot; format:</p>

<pre><code> %% Example n-gram frequency file in &quot;short&quot; format
 __$    2
        PDAT    2
                VVFIN   1
                ADV     1
 ADV    1
        $.      1
                __$     1
 ART    1
                1
                $.      1
 PDAT   2
        VVFIN   1
                ART     1
        ADV     1
                $.      1
 VVFIN  1
        ART     1
                NN      1
 NN     1
        $.      1
                __$     1</code></pre>

</dd>
<dt id="Lexical-Class-Frequency-Files"><b>Lexical-Class Frequency Files</b></dt>
<dd>

<p>Lexical-class frequency files store raw frequencies for known lexical classes (read &quot;sets of possible part-of-speech tags&quot;) and (class,tag) pairs. The format is a direct extension of the format for lexical frequency files (see &quot;Lexical Frequency Files&quot;, above):</p>

<pre><code> CLASS_FILE  ::= ({COMMENT} | {BLANK_LINE} | {CLASS_ENTRY})*
 CLASS_ENTRY ::= {CLASS_ELTS} {TAB} {CLASS_TOTAL} ( {TAB} {TAG_COUNT} )*
 CLASS_ELTS  ::= ( {CLASS_TAG} {SPACE} )*
 CLASS_TAG   ::= ( [^{SPACE}{TAB}{NEWLINE}] )+</code></pre>

<p>As for lexical frequency files, leading and trailing whitespaces are stripped from class and tag text.</p>

<p>The <i>CLASS_ELTS</i> component specifies a (space-separated) list of tags belonging to the lexical class. All other (tab-separated) fields are as for a lexical frequency file.</p>

<p>A pair (CLASS,TAG) such that TAG is not an element of CLASS is called an &quot;contradictory pair&quot; or an &quot;impossible pair&quot;. It is not required that the the tags in the <i>TAG_COUNT</i> components of a <i>CLASS_ENTRY</i> are &quot;possible&quot; in this sense, although it certainly helps if this is the case.</p>

<p>An example lexical class frequency file is:</p>

<pre><code> %% Example lexical frequency file
 PDAT NE        4       PDAT    4
 VVFIN VAFIN    1.0     VVFIN   0.7     VAFIN   0.3
 ART CARD       365     ART     350     CARD    5
 NN VVFIN       1       NN      0.5     VVFIN   0.5
 ADV            1       ADV     1
 $.             42      $.      42</code></pre>

</dd>
<dt id="Flavor-Definition-Files"><b>Flavor Definition Files</b></dt>
<dd>

<p>A flavor definition file stores heuristic rules for surface-typographical classification of otherwise unknown tokens via the C++ <code>mootTaster</code> API. The syntax for flavor definition files is:</p>

<pre><code> FLAVOR_FILE   ::= ({COMMENT} | {NOTAB_LINE} | {CONTENT_LINE})*
 COMMENT       ::= &quot;%%&quot; ([^{NEWLINE}])* {NEWLINE}
 NOTAB_LINE    ::= ([^{TAB}])*
 CONTENT_LINE  ::= {DEFAULT_LINE} | {FLAVOR_RULE}
 DEFAULT_LINE  ::= &quot;DEFAULT&quot; {TAB} {DEFAULT_LABEL}
 DEFAULT_LABEL ::= {LABEL}
 FLAVOR_RULE   ::= {LABEL} {TAB} {REGEX}
 NEWLINE       ::= &quot;\n&quot;
 TAB           ::= &quot;\t&quot;
 LABEL         ::= [^\t\r\n]*
 REGEX         ::= [^\r\r\n]+</code></pre>

<p>Content lines are those non-comment lines containing at least one TAB character. A content line may define a default label <i>DEFAULT_LABEL</i> for the classifier (if unspecified, the default label defaults to the empty string), or an explicit classification rule. Each explicit classification rule has a label <i>LABEL</i> as well as an associated POSIX.2 regular expression <i>REGEX</i> (see regex(7)). By convention, flavor <i>LABEL</i> values begin with &quot;@&quot; and otherwise contain only upper-case ASCII characters, but thse conventions are currently not enforced. Flavor definitions are used by the runtime tagger to obtain lexical probability estimates for otherwise unknown input tokens in the following manner:</p>

<ul>

<li><p>If the token&#39;s input text literally matches an entry in the <a href="#Lexical-Frequency-Files">lexical frequency file</a>, the probabilities estimated from that entry are used.</p>

</li>
<li><p>Otherwise, if the runtime tagger has flavor-based classification enabled, each <i>FLAVOR_RULE</i> is inspected in the order in which it appears in the flavor definition file. If the token&#39;s text matches the regular expression associated with the rule, lexical probabilities are estimated from the lexical entry associated with the rule&#39;s <i>LABEL</i>. Only the first matching flavor rule determines which lexical probabilities are used if this clause obtains.</p>

</li>
<li><p>Otherwise, if flavors are disabled or no flavor rules match but lexical class frequencies are available, then lexical class probabilities from the <a href="#Lexical-Class-Frequency-Files">lexical-class frequency file</a> for the token&#39;s lexical class are used.</p>

</li>
<li><p>Otherwise, probabilities for unknown tokens are estimated using the <b>@UNKNOWN</b> entry of the <a href="#Lexical-Frequency-Files">lexical frequency file</a>.</p>

</li>
</ul>

<p>If no flavor definition file is specified, moot uses a built-in set of classification heuristics equivalent to the following flavor definition file:</p>

<pre><code> %% Flavor definition file for moot
 %%   LC_CTYPE=UTF-8
 @ALPHA         ^[^0-9]
 @CARD          ^([0-9]+)$
 @CARDPUNCT     ^([0-9]+)([,\.\-])$
 @CARDSEPS      ^([0-9])([0-9,\.\-]+)$
 @CARDSUFFIX    ^([0-9])([0-9,\.\-]*)([^0-9,\.\-])(.{0,3})$
 DEFAULT        @ALPHA</code></pre>

<p>Note that the process locale settings (see locale(1), setlocale(3), locale(7)) -- in particular the value of <code>LC_CTYPE</code> -- can and do influence the behavior of the regular expression matching engine. The command-line moot utilities initialize the locale according to the user&#39;s environment variables on start-up. Expect the unexpected if your runtime locale settings differ from those used when training the model, however. For reference, the value of LC_CTYPE at training time is written as a comment to the flavor definition files produced by <a href="./mootrain.html">mootrain</a>, but this comment in and of itself has <b>no effect</b> on the operation of the runtime tagger; the user is responsible for ensuring that his or her locale settings are compatible with those expected by the model.</p>

<p>The program <a href="./moottaste.html">moottaste(1)</a> can be used to test and debug flavor definition files.</p>

</dd>
</dl>

<h2 id="HMM-Binary-Model-Files">HMM Binary Model Files</h2>

<p>A &quot;Binary Model&quot; <i>BINMODEL</i> is a (compressed) binary format file storing a compiled Hidden Markov Model (probabilities and constants). It is completely specified by its filename <i>BINMODEL</i>. By convention, HMM binary model files carry the suffix &quot;.hmm&quot;.</p>

<p>When specifying an HMM model file, note that the existence of a file <i>BINMODEL</i> overrides any text models which might exists in files <i>BINMODEL</i>.lex , <i>BINMODEL</i>.123 , <i>BINMODEL</i>.clx. Use of a conventional suffix (such as &quot;.hmm&quot;) to identify binary models eliminates such problems, since <i>MODEL</i>.hmm will <b>not</b> clash with a text model <i>MODEL</i>.lex, ...</p>

<h2 id="HMM-Dumps">HMM Dumps</h2>

<p>An HMM dump is a plain text file containing all the information stored in a compiled HMM. The format exists solely for purposes of debugging.</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>Development of this package was supported by the project &#39;Kollokationen im W&ouml;rterbuch&#39; ( &quot;collocations in the dictionary&quot;, http://www.bbaw.de/forschung/kollokationen ) in association with the project &#39;Digitales W&ouml;rterbuch der deutschen Sprache des 20. Jahrhunderts (DWDS)&#39; ( &quot;digital dictionary of the German language of the 20th century&quot;, http://www.dwds.de ) at the Berlin-Brandenburgische Akademie der Wissenschaften ( http://www.bbaw.de ) with funding from the Alexander von Humboldt Stiftung ( http://www.avh.de ) and from the Zukunftsinvestitionsprogramm of the German federal government.</p>

<p>I am grateful to Christiane Fellbaum, Alexander Geyken, Gerald Neumann, Edmund Pohl, Alexey Sokirko, and others for offering useful insights in the course of development of this package.</p>

<p>Thomas Hanneforth wrote and maintains the libFSM C++ library for finite-state device operations used in the development of the class-based HMM tagger / disambiguator. Alexander Geyken and Thomas Hanneforth developed the rule-based morphological analysis system for German which was used in the development of the class-based HMM tagger / disambiguator.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Bryan Jurish &lt;moocow@cpan.org&gt;</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="./mootutils.html">mootutils</a></p>


</body>

</html>


